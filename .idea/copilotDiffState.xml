<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/ui/MessageConfigScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/ui/MessageConfigScreen.kt" />
              <option name="originalContent" value="package com.example.apptest2.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MessageConfigScreen(&#10;    buttonNumber: Int,&#10;    currentConfig: MessageConfig,&#10;    onConfigChange: (MessageConfig) -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var config by remember { mutableStateOf(currentConfig) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Configuration - Bouton $buttonNumber&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Retour&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            onConfigChange(config)&#10;                            onBack()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;SAUVEGARDER&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp)&#10;                .verticalScroll(rememberScrollState()),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Nom du message&#10;            OutlinedTextField(&#10;                value = config.name,&#10;                onValueChange = { config = config.copy(name = it) },&#10;                label = { Text(&quot;Nom du bouton&quot;) },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Configuration détaillée de l'événement&#10;            DetailedEventConfigSection(&#10;                detailedEventConfig = config.detailedEventConfig,&#10;                onConfigChange = { newDetailedEventConfig -&gt;&#10;                    config = config.copy(detailedEventConfig = newDetailedEventConfig)&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DetailedEventConfigSection(&#10;    detailedEventConfig: DetailedEventConfig,&#10;    onConfigChange: (DetailedEventConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Configuration Event Détaillée&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;&#10;            // Timing section&#10;            TimingConfigSection(&#10;                rStartEventMs = detailedEventConfig.rStartEventMs,&#10;                rStopEventMs = detailedEventConfig.rStopEventMs,&#10;                mask = detailedEventConfig.mask,&#10;                onTimingChange = { startMs, stopMs, mask -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(&#10;                        rStartEventMs = startMs,&#10;                        rStopEventMs = stopMs,&#10;                        mask = mask&#10;                    ))&#10;                }&#10;            )&#10;&#10;            // Localization section&#10;            LocalizationConfigSection(&#10;                localizationConfig = detailedEventConfig.localization,&#10;                onConfigChange = { newLocalization -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(localization = newLocalization))&#10;                }&#10;            )&#10;&#10;            // Effect section&#10;            DetailedEffectConfigSection(&#10;                effectConfig = detailedEventConfig.effect,&#10;                onConfigChange = { newEffect -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(effect = newEffect))&#10;                }&#10;            )&#10;&#10;            // Layer section&#10;            LayerConfigSection(&#10;                layerConfig = detailedEventConfig.layer,&#10;                onConfigChange = { newLayer -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(layer = newLayer))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimingConfigSection(&#10;    rStartEventMs: Long,&#10;    rStopEventMs: Long,&#10;    mask: Int,&#10;    onTimingChange: (Long, Long, Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;⏱️ Timing &amp; Masque&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = rStartEventMs.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toLongOrNull()?.let { startMs -&gt;&#10;                        if (startMs &gt;= 0 &amp;&amp; startMs &lt; rStopEventMs) {&#10;                            onTimingChange(startMs, rStopEventMs, mask)&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Début (ms)&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = rStopEventMs.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toLongOrNull()?.let { stopMs -&gt;&#10;                        if (stopMs &gt; rStartEventMs) {&#10;                            onTimingChange(rStartEventMs, stopMs, mask)&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Fin (ms)&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = mask.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { maskValue -&gt;&#10;                        if (maskValue in 0..255) {&#10;                            onTimingChange(rStartEventMs, rStopEventMs, maskValue)&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Masque (0-255)&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LocalizationConfigSection(&#10;    localizationConfig: LocalizationConfig,&#10;    onConfigChange: (LocalizationConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot; Localisation&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = localizationConfig.mapId.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { mapId -&gt;&#10;                        if (mapId in 0..255) {&#10;                            onConfigChange(localizationConfig.copy(mapId = mapId))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Map ID (0-255)&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = localizationConfig.focus.toString(),&#10;                    onValueChange = { value -&gt;&#10;                        value.toIntOrNull()?.let { focus -&gt;&#10;                            if (focus in 0..255) {&#10;                                onConfigChange(localizationConfig.copy(focus = focus))&#10;                            }&#10;                        }&#10;                    },&#10;                    label = { Text(&quot;Focus (×10cm)&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = localizationConfig.zoom.toString(),&#10;                    onValueChange = { value -&gt;&#10;                        value.toIntOrNull()?.let { zoom -&gt;&#10;                            if (zoom in 0..255) {&#10;                                onConfigChange(localizationConfig.copy(zoom = zoom))&#10;                            }&#10;                        }&#10;                    },&#10;                    label = { Text(&quot;Zoom (×10cm)&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            GoboTypeSelector(&#10;                selectedGoboType = localizationConfig.goboType,&#10;                onGoboTypeSelected = { newGoboType -&gt;&#10;                    onConfigChange(localizationConfig.copy(goboType = newGoboType))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GoboTypeSelector(&#10;    selectedGoboType: GoboType,&#10;    onGoboTypeSelected: (GoboType) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    Column {&#10;        Text(&#10;            text = &quot;Type GOBO&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        ExposedDropdownMenuBox(&#10;            expanded = expanded,&#10;            onExpandedChange = { expanded = !expanded }&#10;        ) {&#10;            OutlinedTextField(&#10;                value = when (selectedGoboType) {&#10;                    GoboType.NONE -&gt; &quot;Aucun&quot;&#10;                    GoboType.POINT -&gt; &quot;Point&quot;&#10;                    GoboType.LINE -&gt; &quot;Ligne&quot;&#10;                    GoboType.POLYGON -&gt; &quot;Polygone&quot;&#10;                },&#10;                onValueChange = {},&#10;                readOnly = true,&#10;                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },&#10;                modifier = Modifier&#10;                    .menuAnchor()&#10;                    .fillMaxWidth()&#10;            )&#10;&#10;            ExposedDropdownMenu(&#10;                expanded = expanded,&#10;                onDismissRequest = { expanded = false }&#10;            ) {&#10;                GoboType.entries.forEach { goboType -&gt;&#10;                    DropdownMenuItem(&#10;                        text = {&#10;                            Text(when (goboType) {&#10;                                GoboType.NONE -&gt; &quot;Aucun&quot;&#10;                                GoboType.POINT -&gt; &quot;Point&quot;&#10;                                GoboType.LINE -&gt; &quot;Ligne&quot;&#10;                                GoboType.POLYGON -&gt; &quot;Polygone&quot;&#10;                            })&#10;                        },&#10;                        onClick = {&#10;                            onGoboTypeSelected(goboType)&#10;                            expanded = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DetailedEffectConfigSection(&#10;    effectConfig: DetailedEffectConfig,&#10;    onConfigChange: (DetailedEffectConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;✨ Effet&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            EventStyleSelector(&#10;                selectedStyle = effectConfig.style,&#10;                onStyleSelected = { newStyle -&gt;&#10;                    onConfigChange(effectConfig.copy(style = newStyle))&#10;                }&#10;            )&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = effectConfig.frequency.toString(),&#10;                    onValueChange = { value -&gt;&#10;                        value.toIntOrNull()?.let { frequency -&gt;&#10;                            if (frequency in 1..255) {&#10;                                onConfigChange(effectConfig.copy(frequency = frequency))&#10;                            }&#10;                        }&#10;                    },&#10;                    label = { Text(&quot;Fréq. (Hz)&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = effectConfig.duration.toString(),&#10;                    onValueChange = { value -&gt;&#10;                        value.toIntOrNull()?.let { duration -&gt;&#10;                            if (duration in 0..255) {&#10;                                onConfigChange(effectConfig.copy(duration = duration))&#10;                            }&#10;                        }&#10;                    },&#10;                    label = { Text(&quot;Durée (ms)&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            OutlinedTextField(&#10;                value = effectConfig.intensity.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { intensity -&gt;&#10;                        if (intensity in 0..255) {&#10;                            onConfigChange(effectConfig.copy(intensity = intensity))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Intensité (0-255)&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            EventColorPicker(&#10;                color = effectConfig.color,&#10;                onColorChange = { newColor -&gt;&#10;                    onConfigChange(effectConfig.copy(color = newColor))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EventStyleSelector(&#10;    selectedStyle: EventStyle,&#10;    onStyleSelected: (EventStyle) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    Column {&#10;        Text(&#10;            text = &quot;Style&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        ExposedDropdownMenuBox(&#10;            expanded = expanded,&#10;            onExpandedChange = { expanded = !expanded }&#10;        ) {&#10;            OutlinedTextField(&#10;                value = selectedStyle.name,&#10;                onValueChange = {},&#10;                readOnly = true,&#10;                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },&#10;                modifier = Modifier&#10;                    .menuAnchor()&#10;                    .fillMaxWidth()&#10;            )&#10;&#10;            ExposedDropdownMenu(&#10;                expanded = expanded,&#10;                onDismissRequest = { expanded = false }&#10;            ) {&#10;                EventStyle.entries.forEach { style -&gt;&#10;                    DropdownMenuItem(&#10;                        text = { Text(style.name) },&#10;                        onClick = {&#10;                            onStyleSelected(style)&#10;                            expanded = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EventColorPicker(&#10;    color: EventColor,&#10;    onColorChange: (EventColor) -&gt; Unit&#10;) {&#10;    Column(&#10;        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Couleur RGBW + Vibration&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        // Première ligne : Rouge, Vert, Bleu&#10;        Row(&#10;            horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;        ) {&#10;            OutlinedTextField(&#10;                value = color.red.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { red -&gt;&#10;                        if (red in 0..255) {&#10;                            onColorChange(color.copy(red = red))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;R&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = color.green.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { green -&gt;&#10;                        if (green in 0..255) {&#10;                            onColorChange(color.copy(green = green))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;G&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = color.blue.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { blue -&gt;&#10;                        if (blue in 0..255) {&#10;                            onColorChange(color.copy(blue = blue))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;B&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;&#10;        // Deuxième ligne : Blanc, Vibration&#10;        Row(&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            OutlinedTextField(&#10;                value = color.white.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { white -&gt;&#10;                        if (white in 0..255) {&#10;                            onColorChange(color.copy(white = white))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Blanc&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;&#10;            OutlinedTextField(&#10;                value = color.vibration.toString(),&#10;                onValueChange = { value -&gt;&#10;                    value.toIntOrNull()?.let { vibration -&gt;&#10;                        if (vibration in 0..255) {&#10;                            onColorChange(color.copy(vibration = vibration))&#10;                        }&#10;                    }&#10;                },&#10;                label = { Text(&quot;Vibration&quot;) },&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;&#10;        // Aperçu de la couleur RGB&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = androidx.compose.ui.graphics.Color(color.red, color.green, color.blue)&#10;            )&#10;        ) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;RGBW(${color.red},${color.green},${color.blue},${color.white}) V:${color.vibration}&quot;,&#10;                    fontSize = 10.sp,&#10;                    color = if (color.red + color.green + color.blue &gt; 384) {&#10;                        androidx.compose.ui.graphics.Color.Black&#10;                    } else {&#10;                        androidx.compose.ui.graphics.Color.White&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LayerConfigSection(&#10;    layerConfig: LayerConfig,&#10;    onConfigChange: (LayerConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot; Layer&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = layerConfig.nbr.toString(),&#10;                    onValueChange = { value -&gt;&#10;                        value.toIntOrNull()?.let { nbr -&gt;&#10;                            if (nbr in 0..255) {&#10;                                onConfigChange(layerConfig.copy(nbr = nbr))&#10;                            }&#10;                        }&#10;                    },&#10;                    label = { Text(&quot;Numéro&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = layerConfig.opacity.toString(),&#10;                    onValueChange = { value -&gt;&#10;                        value.toIntOrNull()?.let { opacity -&gt;&#10;                            if (opacity in 0..255) {&#10;                                onConfigChange(layerConfig.copy(opacity = opacity))&#10;                            }&#10;                        }&#10;                    },&#10;                    label = { Text(&quot;Opacité (0-255)&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            BlendingModeSelector(&#10;                selectedBlendingMode = layerConfig.blendingMode,&#10;                onBlendingModeSelected = { newBlendingMode -&gt;&#10;                    onConfigChange(layerConfig.copy(blendingMode = newBlendingMode))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun BlendingModeSelector(&#10;    selectedBlendingMode: BlendingMode,&#10;    onBlendingModeSelected: (BlendingMode) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    Column {&#10;        Text(&#10;            text = &quot;Mode de mélange&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        ExposedDropdownMenuBox(&#10;            expanded = expanded,&#10;            onExpandedChange = { expanded = !expanded }&#10;        ) {&#10;            OutlinedTextField(&#10;                value = when (selectedBlendingMode) {&#10;                    BlendingMode.NORMAL -&gt; &quot;Normal&quot;&#10;                    BlendingMode.ADD -&gt; &quot;Addition&quot;&#10;                    BlendingMode.AND -&gt; &quot;ET logique&quot;&#10;                    BlendingMode.SUBSTRACT -&gt; &quot;Soustraction&quot;&#10;                    BlendingMode.MULTIPLY -&gt; &quot;Multiplication&quot;&#10;                    BlendingMode.DIVIDE -&gt; &quot;Division&quot;&#10;                },&#10;                onValueChange = {},&#10;                readOnly = true,&#10;                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },&#10;                modifier = Modifier&#10;                    .menuAnchor()&#10;                    .fillMaxWidth()&#10;            )&#10;&#10;            ExposedDropdownMenu(&#10;                expanded = expanded,&#10;                onDismissRequest = { expanded = false }&#10;            ) {&#10;                BlendingMode.entries.forEach { blendingMode -&gt;&#10;                    DropdownMenuItem(&#10;                        text = {&#10;                            Text(when (blendingMode) {&#10;                                BlendingMode.NORMAL -&gt; &quot;Normal&quot;&#10;                                BlendingMode.ADD -&gt; &quot;Addition&quot;&#10;                                BlendingMode.AND -&gt; &quot;ET logique&quot;&#10;                                BlendingMode.SUBSTRACT -&gt; &quot;Soustraction&quot;&#10;                                BlendingMode.MULTIPLY -&gt; &quot;Multiplication&quot;&#10;                                BlendingMode.DIVIDE -&gt; &quot;Division&quot;&#10;                            })&#10;                        },&#10;                        onClick = {&#10;                            onBlendingModeSelected(blendingMode)&#10;                            expanded = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.apptest2.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.apptest2.ui.components.ValidatedIntField&#10;import com.example.apptest2.ui.components.ValidatedNumericField&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MessageConfigScreen(&#10;    buttonNumber: Int,&#10;    currentConfig: MessageConfig,&#10;    onConfigChange: (MessageConfig) -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var config by remember { mutableStateOf(currentConfig) }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Configuration - Bouton $buttonNumber&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Retour&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            onConfigChange(config)&#10;                            onBack()&#10;                        }&#10;                    ) {&#10;                        Text(&quot;SAUVEGARDER&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp)&#10;                .verticalScroll(rememberScrollState()),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Nom du message&#10;            OutlinedTextField(&#10;                value = config.name,&#10;                onValueChange = { config = config.copy(name = it) },&#10;                label = { Text(&quot;Nom du bouton&quot;) },&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Configuration détaillée de l'événement&#10;            DetailedEventConfigSection(&#10;                detailedEventConfig = config.detailedEventConfig,&#10;                onConfigChange = { newDetailedEventConfig -&gt;&#10;                    config = config.copy(detailedEventConfig = newDetailedEventConfig)&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DetailedEventConfigSection(&#10;    detailedEventConfig: DetailedEventConfig,&#10;    onConfigChange: (DetailedEventConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Configuration Event Détaillée&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;&#10;            // Timing section&#10;            TimingConfigSection(&#10;                rStartEventMs = detailedEventConfig.rStartEventMs,&#10;                rStopEventMs = detailedEventConfig.rStopEventMs,&#10;                mask = detailedEventConfig.mask,&#10;                onTimingChange = { startMs, stopMs, mask -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(&#10;                        rStartEventMs = startMs,&#10;                        rStopEventMs = stopMs,&#10;                        mask = mask&#10;                    ))&#10;                }&#10;            )&#10;&#10;            // Localization section&#10;            LocalizationConfigSection(&#10;                localizationConfig = detailedEventConfig.localization,&#10;                onConfigChange = { newLocalization -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(localization = newLocalization))&#10;                }&#10;            )&#10;&#10;            // Effect section&#10;            DetailedEffectConfigSection(&#10;                effectConfig = detailedEventConfig.effect,&#10;                onConfigChange = { newEffect -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(effect = newEffect))&#10;                }&#10;            )&#10;&#10;            // Layer section&#10;            LayerConfigSection(&#10;                layerConfig = detailedEventConfig.layer,&#10;                onConfigChange = { newLayer -&gt;&#10;                    onConfigChange(detailedEventConfig.copy(layer = newLayer))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimingConfigSection(&#10;    rStartEventMs: Long,&#10;    rStopEventMs: Long,&#10;    mask: Int,&#10;    onTimingChange: (Long, Long, Int) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;⏱️ Timing &amp; Masque&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            ValidatedNumericField(&#10;                value = rStartEventMs,&#10;                onValueChange = { startMs -&gt;&#10;                    if (startMs &gt;= 0 &amp;&amp; startMs &lt; rStopEventMs) {&#10;                        onTimingChange(startMs, rStopEventMs, mask)&#10;                    }&#10;                },&#10;                label = &quot;Début (ms)&quot;,&#10;                range = 0L..Long.MAX_VALUE,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                showStepButtons = false&#10;            )&#10;&#10;            ValidatedNumericField(&#10;                value = rStopEventMs,&#10;                onValueChange = { stopMs -&gt;&#10;                    if (stopMs &gt; rStartEventMs) {&#10;                        onTimingChange(rStartEventMs, stopMs, mask)&#10;                    }&#10;                },&#10;                label = &quot;Fin (ms)&quot;,&#10;                range = 0L..Long.MAX_VALUE,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                showStepButtons = false&#10;            )&#10;&#10;            ValidatedIntField(&#10;                value = mask,&#10;                onValueChange = { maskValue -&gt;&#10;                    onTimingChange(rStartEventMs, rStopEventMs, maskValue)&#10;                },&#10;                label = &quot;Masque (0-255)&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                showStepButtons = true&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LocalizationConfigSection(&#10;    localizationConfig: LocalizationConfig,&#10;    onConfigChange: (LocalizationConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot; Localisation&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            ValidatedIntField(&#10;                value = localizationConfig.mapId,&#10;                onValueChange = { mapId -&gt;&#10;                    onConfigChange(localizationConfig.copy(mapId = mapId))&#10;                },&#10;                label = &quot;Map ID (0-255)&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                showStepButtons = true&#10;            )&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                ValidatedIntField(&#10;                    value = localizationConfig.focus,&#10;                    onValueChange = { focus -&gt;&#10;                        onConfigChange(localizationConfig.copy(focus = focus))&#10;                    },&#10;                    label = &quot;Focus (×10cm)&quot;,&#10;                    range = 0..255,&#10;                    modifier = Modifier.weight(1f),&#10;                    showStepButtons = true&#10;                )&#10;&#10;                ValidatedIntField(&#10;                    value = localizationConfig.zoom,&#10;                    onValueChange = { zoom -&gt;&#10;                        onConfigChange(localizationConfig.copy(zoom = zoom))&#10;                    },&#10;                    label = &quot;Zoom (×10cm)&quot;,&#10;                    range = 0..255,&#10;                    modifier = Modifier.weight(1f),&#10;                    showStepButtons = true&#10;                )&#10;            }&#10;&#10;            GoboTypeSelector(&#10;                selectedGoboType = localizationConfig.goboType,&#10;                onGoboTypeSelected = { newGoboType -&gt;&#10;                    onConfigChange(localizationConfig.copy(goboType = newGoboType))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GoboTypeSelector(&#10;    selectedGoboType: GoboType,&#10;    onGoboTypeSelected: (GoboType) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    Column {&#10;        Text(&#10;            text = &quot;Type GOBO&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        ExposedDropdownMenuBox(&#10;            expanded = expanded,&#10;            onExpandedChange = { expanded = !expanded }&#10;        ) {&#10;            OutlinedTextField(&#10;                value = when (selectedGoboType) {&#10;                    GoboType.NONE -&gt; &quot;Aucun&quot;&#10;                    GoboType.POINT -&gt; &quot;Point&quot;&#10;                    GoboType.LINE -&gt; &quot;Ligne&quot;&#10;                    GoboType.POLYGON -&gt; &quot;Polygone&quot;&#10;                },&#10;                onValueChange = {},&#10;                readOnly = true,&#10;                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },&#10;                modifier = Modifier&#10;                    .menuAnchor()&#10;                    .fillMaxWidth()&#10;            )&#10;&#10;            ExposedDropdownMenu(&#10;                expanded = expanded,&#10;                onDismissRequest = { expanded = false }&#10;            ) {&#10;                GoboType.entries.forEach { goboType -&gt;&#10;                    DropdownMenuItem(&#10;                        text = {&#10;                            Text(when (goboType) {&#10;                                GoboType.NONE -&gt; &quot;Aucun&quot;&#10;                                GoboType.POINT -&gt; &quot;Point&quot;&#10;                                GoboType.LINE -&gt; &quot;Ligne&quot;&#10;                                GoboType.POLYGON -&gt; &quot;Polygone&quot;&#10;                            })&#10;                        },&#10;                        onClick = {&#10;                            onGoboTypeSelected(goboType)&#10;                            expanded = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DetailedEffectConfigSection(&#10;    effectConfig: DetailedEffectConfig,&#10;    onConfigChange: (DetailedEffectConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;✨ Effet&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            EventStyleSelector(&#10;                selectedStyle = effectConfig.style,&#10;                onStyleSelected = { newStyle -&gt;&#10;                    onConfigChange(effectConfig.copy(style = newStyle))&#10;                }&#10;            )&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                ValidatedIntField(&#10;                    value = effectConfig.frequency,&#10;                    onValueChange = { frequency -&gt;&#10;                        onConfigChange(effectConfig.copy(frequency = frequency))&#10;                    },&#10;                    label = &quot;Fréq. (Hz)&quot;,&#10;                    range = 1..255,&#10;                    modifier = Modifier.weight(1f),&#10;                    showStepButtons = true&#10;                )&#10;&#10;                ValidatedIntField(&#10;                    value = effectConfig.duration,&#10;                    onValueChange = { duration -&gt;&#10;                        onConfigChange(effectConfig.copy(duration = duration))&#10;                    },&#10;                    label = &quot;Durée (ms)&quot;,&#10;                    range = 0..255,&#10;                    modifier = Modifier.weight(1f),&#10;                    showStepButtons = true&#10;                )&#10;            }&#10;&#10;            ValidatedIntField(&#10;                value = effectConfig.intensity,&#10;                onValueChange = { intensity -&gt;&#10;                    onConfigChange(effectConfig.copy(intensity = intensity))&#10;                },&#10;                label = &quot;Intensité (0-255)&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.fillMaxWidth(),&#10;                showStepButtons = true&#10;            )&#10;&#10;            EventColorPicker(&#10;                color = effectConfig.color,&#10;                onColorChange = { newColor -&gt;&#10;                    onConfigChange(effectConfig.copy(color = newColor))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EventStyleSelector(&#10;    selectedStyle: EventStyle,&#10;    onStyleSelected: (EventStyle) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    Column {&#10;        Text(&#10;            text = &quot;Style&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        ExposedDropdownMenuBox(&#10;            expanded = expanded,&#10;            onExpandedChange = { expanded = !expanded }&#10;        ) {&#10;            OutlinedTextField(&#10;                value = selectedStyle.name,&#10;                onValueChange = {},&#10;                readOnly = true,&#10;                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },&#10;                modifier = Modifier&#10;                    .menuAnchor()&#10;                    .fillMaxWidth()&#10;            )&#10;&#10;            ExposedDropdownMenu(&#10;                expanded = expanded,&#10;                onDismissRequest = { expanded = false }&#10;            ) {&#10;                EventStyle.entries.forEach { style -&gt;&#10;                    DropdownMenuItem(&#10;                        text = { Text(style.name) },&#10;                        onClick = {&#10;                            onStyleSelected(style)&#10;                            expanded = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EventColorPicker(&#10;    color: EventColor,&#10;    onColorChange: (EventColor) -&gt; Unit&#10;) {&#10;    Column(&#10;        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Couleur RGBW + Vibration&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        // Première ligne : Rouge, Vert, Bleu&#10;        Row(&#10;            horizontalArrangement = Arrangement.spacedBy(4.dp)&#10;        ) {&#10;            ValidatedIntField(&#10;                value = color.red,&#10;                onValueChange = { red -&gt;&#10;                    onColorChange(color.copy(red = red))&#10;                },&#10;                label = &quot;R&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.weight(1f),&#10;                showStepButtons = true&#10;            )&#10;&#10;            ValidatedIntField(&#10;                value = color.green,&#10;                onValueChange = { green -&gt;&#10;                    onColorChange(color.copy(green = green))&#10;                },&#10;                label = &quot;G&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.weight(1f),&#10;                showStepButtons = true&#10;            )&#10;&#10;            ValidatedIntField(&#10;                value = color.blue,&#10;                onValueChange = { blue -&gt;&#10;                    onColorChange(color.copy(blue = blue))&#10;                },&#10;                label = &quot;B&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.weight(1f),&#10;                showStepButtons = true&#10;            )&#10;        }&#10;&#10;        // Deuxième ligne : Blanc, Vibration&#10;        Row(&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            ValidatedIntField(&#10;                value = color.white,&#10;                onValueChange = { white -&gt;&#10;                    onColorChange(color.copy(white = white))&#10;                },&#10;                label = &quot;Blanc&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.weight(1f),&#10;                showStepButtons = true&#10;            )&#10;&#10;            ValidatedIntField(&#10;                value = color.vibration,&#10;                onValueChange = { vibration -&gt;&#10;                    onColorChange(color.copy(vibration = vibration))&#10;                },&#10;                label = &quot;Vibration&quot;,&#10;                range = 0..255,&#10;                modifier = Modifier.weight(1f),&#10;                showStepButtons = true&#10;            )&#10;        }&#10;&#10;        // Aperçu de la couleur RGB&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = androidx.compose.ui.graphics.Color(color.red, color.green, color.blue)&#10;            )&#10;        ) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;RGBW(${color.red},${color.green},${color.blue},${color.white}) V:${color.vibration}&quot;,&#10;                    fontSize = 10.sp,&#10;                    color = if (color.red + color.green + color.blue &gt; 384) {&#10;                        androidx.compose.ui.graphics.Color.Black&#10;                    } else {&#10;                        androidx.compose.ui.graphics.Color.White&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LayerConfigSection(&#10;    layerConfig: LayerConfig,&#10;    onConfigChange: (LayerConfig) -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot; Layer&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                ValidatedIntField(&#10;                    value = layerConfig.nbr,&#10;                    onValueChange = { nbr -&gt;&#10;                        onConfigChange(layerConfig.copy(nbr = nbr))&#10;                    },&#10;                    label = &quot;Numéro&quot;,&#10;                    range = 0..255,&#10;                    modifier = Modifier.weight(1f),&#10;                    showStepButtons = true&#10;                )&#10;&#10;                ValidatedIntField(&#10;                    value = layerConfig.opacity,&#10;                    onValueChange = { opacity -&gt;&#10;                        onConfigChange(layerConfig.copy(opacity = opacity))&#10;                    },&#10;                    label = &quot;Opacité (0-255)&quot;,&#10;                    range = 0..255,&#10;                    modifier = Modifier.weight(1f),&#10;                    showStepButtons = true&#10;                )&#10;            }&#10;&#10;            BlendingModeSelector(&#10;                selectedBlendingMode = layerConfig.blendingMode,&#10;                onBlendingModeSelected = { newBlendingMode -&gt;&#10;                    onConfigChange(layerConfig.copy(blendingMode = newBlendingMode))&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun BlendingModeSelector(&#10;    selectedBlendingMode: BlendingMode,&#10;    onBlendingModeSelected: (BlendingMode) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    Column {&#10;        Text(&#10;            text = &quot;Mode de mélange&quot;,&#10;            style = MaterialTheme.typography.labelMedium&#10;        )&#10;&#10;        ExposedDropdownMenuBox(&#10;            expanded = expanded,&#10;            onExpandedChange = { expanded = !expanded }&#10;        ) {&#10;            OutlinedTextField(&#10;                value = when (selectedBlendingMode) {&#10;                    BlendingMode.NORMAL -&gt; &quot;Normal&quot;&#10;                    BlendingMode.ADD -&gt; &quot;Addition&quot;&#10;                    BlendingMode.AND -&gt; &quot;ET logique&quot;&#10;                    BlendingMode.SUBSTRACT -&gt; &quot;Soustraction&quot;&#10;                    BlendingMode.MULTIPLY -&gt; &quot;Multiplication&quot;&#10;                    BlendingMode.DIVIDE -&gt; &quot;Division&quot;&#10;                },&#10;                onValueChange = {},&#10;                readOnly = true,&#10;                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },&#10;                modifier = Modifier&#10;                    .menuAnchor()&#10;                    .fillMaxWidth()&#10;            )&#10;&#10;            ExposedDropdownMenu(&#10;                expanded = expanded,&#10;                onDismissRequest = { expanded = false }&#10;            ) {&#10;                BlendingMode.entries.forEach { blendingMode -&gt;&#10;                    DropdownMenuItem(&#10;                        text = {&#10;                            Text(when (blendingMode) {&#10;                                BlendingMode.NORMAL -&gt; &quot;Normal&quot;&#10;                                BlendingMode.ADD -&gt; &quot;Addition&quot;&#10;                                BlendingMode.AND -&gt; &quot;ET logique&quot;&#10;                                BlendingMode.SUBSTRACT -&gt; &quot;Soustraction&quot;&#10;                                BlendingMode.MULTIPLY -&gt; &quot;Multiplication&quot;&#10;                                BlendingMode.DIVIDE -&gt; &quot;Division&quot;&#10;                            })&#10;                        },&#10;                        onClick = {&#10;                            onBlendingModeSelected(blendingMode)&#10;                            expanded = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/ui/components/SelectAllOnFocusTextField.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/ui/components/SelectAllOnFocusTextField.kt" />
              <option name="updatedContent" value="package com.example.apptest2.ui.components&#10;&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.text.selection.TextSelectionColors&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.focus.onFocusChanged&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.text.TextRange&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;&#10;@Composable&#10;fun SelectAllOnFocusTextField(&#10;    value: String,&#10;    onValueChange: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    content: @Composable (String, (String) -&gt; Unit, Modifier) -&gt; Unit&#10;) {&#10;    var textFieldValue by remember { &#10;        mutableStateOf(TextFieldValue(value, TextRange(0, 0))) &#10;    }&#10;    &#10;    // Synchroniser avec la valeur externe&#10;    LaunchedEffect(value) {&#10;        if (textFieldValue.text != value) {&#10;            textFieldValue = TextFieldValue(value, TextRange(0, 0))&#10;        }&#10;    }&#10;    &#10;    content(&#10;        textFieldValue.text,&#10;        { newValue -&gt;&#10;            textFieldValue = TextFieldValue(newValue, TextRange(newValue.length))&#10;            onValueChange(newValue)&#10;        },&#10;        modifier.onFocusChanged { focusState -&gt;&#10;            if (focusState.isFocused &amp;&amp; textFieldValue.selection.length == 0) {&#10;                // Sélectionner tout le texte quand le champ reçoit le focus&#10;                textFieldValue = textFieldValue.copy(&#10;                    selection = TextRange(0, textFieldValue.text.length)&#10;                )&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/ui/components/ValidatedNumericField.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/ui/components/ValidatedNumericField.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.apptest2.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.text.selection.SelectionContainer&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.focus.onFocusChanged&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun ValidatedNumericField(&#10;    value: Long,&#10;    onValueChange: (Long) -&gt; Unit,&#10;    label: String,&#10;    range: LongRange = 0L..Long.MAX_VALUE,&#10;    step: Long = 1L,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true,&#10;    supportingText: String? = null,&#10;    showStepButtons: Boolean = true&#10;) {&#10;    var textValue by remember(value) { mutableStateOf(value.toString()) }&#10;    var isValid by remember { mutableStateOf(true) }&#10;    var hasFocus by remember { mutableStateOf(false) }&#10;&#10;    // Validation de la valeur&#10;    val validateAndUpdate = { input: String -&gt;&#10;        val numericValue = input.toLongOrNull()&#10;        when {&#10;            input.isEmpty() -&gt; {&#10;                isValid = false&#10;                textValue = input&#10;            }&#10;            numericValue == null -&gt; {&#10;                isValid = false&#10;                textValue = input&#10;            }&#10;            numericValue !in range -&gt; {&#10;                isValid = false&#10;                textValue = input&#10;            }&#10;            else -&gt; {&#10;                isValid = true&#10;                textValue = input&#10;                onValueChange(numericValue)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Correction automatique quand le champ perd le focus&#10;    val handleFocusLost = {&#10;        if (!isValid || textValue.isEmpty()) {&#10;            // Restaurer la dernière valeur valide&#10;            textValue = value.toString()&#10;            isValid = true&#10;        }&#10;    }&#10;&#10;    if (showStepButtons) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;            modifier = modifier&#10;        ) {&#10;            // Bouton diminuer&#10;            IconButton(&#10;                onClick = {&#10;                    val newValue = (value - step).coerceIn(range)&#10;                    onValueChange(newValue)&#10;                },&#10;                enabled = enabled &amp;&amp; value &gt; range.first&#10;            ) {&#10;                Icon(Icons.Filled.KeyboardArrowDown, contentDescription = &quot;Diminuer&quot;)&#10;            }&#10;&#10;            // Champ de saisie&#10;            OutlinedTextField(&#10;                value = textValue,&#10;                onValueChange = validateAndUpdate,&#10;                label = { Text(label) },&#10;                isError = !isValid,&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                enabled = enabled,&#10;                singleLine = true,&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .onFocusChanged { focusState -&gt;&#10;                        val wasFocused = hasFocus&#10;                        hasFocus = focusState.isFocused&#10;&#10;                        if (wasFocused &amp;&amp; !focusState.isFocused) {&#10;                            handleFocusLost()&#10;                        }&#10;                    },&#10;                supportingText = {&#10;                    when {&#10;                        !isValid &amp;&amp; textValue.toLongOrNull() == null -&gt; {&#10;                            Text(&quot;Valeur numérique requise&quot;, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                        !isValid &amp;&amp; textValue.toLongOrNull() != null -&gt; {&#10;                            Text(&quot;Valeur doit être entre ${range.first} et ${range.last}&quot;, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                        supportingText != null -&gt; {&#10;                            Text(supportingText)&#10;                        }&#10;                        else -&gt; {&#10;                            Text(&quot;${range.first} - ${range.last}&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;&#10;            // Bouton augmenter&#10;            IconButton(&#10;                onClick = {&#10;                    val newValue = (value + step).coerceIn(range)&#10;                    onValueChange(newValue)&#10;                },&#10;                enabled = enabled &amp;&amp; value &lt; range.last&#10;            ) {&#10;                Icon(Icons.Filled.KeyboardArrowUp, contentDescription = &quot;Augmenter&quot;)&#10;            }&#10;        }&#10;    } else {&#10;        // Version sans boutons +/-&#10;        OutlinedTextField(&#10;            value = textValue,&#10;            onValueChange = validateAndUpdate,&#10;            label = { Text(label) },&#10;            isError = !isValid,&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;            enabled = enabled,&#10;            singleLine = true,&#10;            modifier = modifier&#10;                .onFocusChanged { focusState -&gt;&#10;                    val wasFocused = hasFocus&#10;                    hasFocus = focusState.isFocused&#10;&#10;                    if (wasFocused &amp;&amp; !focusState.isFocused) {&#10;                        handleFocusLost()&#10;                    }&#10;                },&#10;            supportingText = {&#10;                when {&#10;                    !isValid &amp;&amp; textValue.toLongOrNull() == null -&gt; {&#10;                        Text(&quot;Valeur numérique requise&quot;, color = MaterialTheme.colorScheme.error)&#10;                    }&#10;                    !isValid &amp;&amp; textValue.toLongOrNull() != null -&gt; {&#10;                        Text(&quot;Valeur doit être entre ${range.first} et ${range.last}&quot;, color = MaterialTheme.colorScheme.error)&#10;                    }&#10;                    supportingText != null -&gt; {&#10;                        Text(supportingText)&#10;                    }&#10;                    else -&gt; {&#10;                        Text(&quot;${range.first} - ${range.last}&quot;)&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ValidatedIntField(&#10;    value: Int,&#10;    onValueChange: (Int) -&gt; Unit,&#10;    label: String,&#10;    range: IntRange = 0..Int.MAX_VALUE,&#10;    step: Int = 1,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true,&#10;    supportingText: String? = null,&#10;    showStepButtons: Boolean = true&#10;) {&#10;    ValidatedNumericField(&#10;        value = value.toLong(),&#10;        onValueChange = { newValue -&gt; onValueChange(newValue.toInt()) },&#10;        label = label,&#10;        range = range.first.toLong()..range.last.toLong(),&#10;        step = step.toLong(),&#10;        modifier = modifier,&#10;        enabled = enabled,&#10;        supportingText = supportingText,&#10;        showStepButtons = showStepButtons&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>