<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt" />
              <option name="originalContent" value="# CMakeLists.txt pour la bibliothèque wristband_native&#10;&#10;cmake_minimum_required(VERSION 3.22.1)&#10;&#10;# Nom du projet&#10;project(&quot;wristband_native&quot;)&#10;&#10;# Standard C++&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# Inclure les headers de la librairie wristband_objects&#10;include_directories(${CMAKE_SOURCE_DIR}/wristband_obje)&#10;&#10;# Sources de la librairie wristband_objects (tous dans une seule lib pour Android)&#10;set(WRISTBAND_SOURCES&#10;    wristband_obje/BufferUtils.cpp&#10;    wristband_obje/CoordinatesRef.cpp&#10;    wristband_obje/Event.cpp&#10;    wristband_obje/OTA_flash_message.cpp&#10;    wristband_obje/RCoordinates.cpp&#10;    wristband_obje/control.cpp&#10;    wristband_obje/event_lib.cpp&#10;    wristband_obje/rtime.cpp&#10;    wristband_obje/sys_cfg.cpp&#10;)&#10;&#10;# Source JNI&#10;set(JNI_SOURCES&#10;    wristband_jni.cpp&#10;)&#10;&#10;# Créer la bibliothèque partagée unique pour Android&#10;add_library(&#10;    wristband_native&#10;    SHARED&#10;    ${WRISTBAND_SOURCES}&#10;    ${JNI_SOURCES}&#10;)&#10;&#10;# Configurer les propriétés de compilation&#10;set_target_properties(wristband_native PROPERTIES&#10;    POSITION_INDEPENDENT_CODE ON&#10;    CXX_STANDARD 17&#10;    CXX_STANDARD_REQUIRED ON&#10;)&#10;&#10;# Lier avec les bibliothèques Android nécessaires&#10;find_library(log-lib log)&#10;find_library(android-lib android)&#10;&#10;target_link_libraries(&#10;    wristband_native&#10;    ${log-lib}&#10;    ${android-lib}&#10;)&#10;&#10;# Définir les flags de compilation&#10;target_compile_definitions(wristband_native PRIVATE&#10;    ANDROID_BUILD=1&#10;    _GNU_SOURCE=1&#10;)&#10;&#10;# Optimisations et flags spécifiques&#10;target_compile_options(wristband_native PRIVATE&#10;    -Wall&#10;    -Wextra&#10;    -fPIC&#10;)&#10;&#10;# Optimisations pour la release&#10;if(CMAKE_BUILD_TYPE STREQUAL &quot;Release&quot;)&#10;    target_compile_options(wristband_native PRIVATE -O3 -DNDEBUG)&#10;else()&#10;    target_compile_options(wristband_native PRIVATE -O0 -g)&#10;endif()&#10;" />
              <option name="updatedContent" value="# CMakeLists.txt pour la bibliothèque wristband_native&#10;&#10;cmake_minimum_required(VERSION 3.22.1)&#10;&#10;# Nom du projet&#10;project(&quot;wristband_native&quot;)&#10;&#10;# Standard C++&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# Inclure les headers de la librairie wristband_objects&#10;include_directories(${CMAKE_SOURCE_DIR}/wristband_obje)&#10;&#10;# Sources de la librairie wristband_objects (tous dans une seule lib pour Android)&#10;set(WRISTBAND_SOURCES&#10;    wristband_obje/control.cpp&#10;    wristband_obje/Event.cpp&#10;    wristband_obje/BufferUtils.cpp&#10;    wristband_obje/CoordinatesRef.cpp&#10;    wristband_obje/OTA_flash_message.cpp&#10;    wristband_obje/RCoordinates.cpp&#10;    wristband_obje/event_lib.cpp&#10;    wristband_obje/rtime.cpp&#10;    wristband_obje/sys_cfg.cpp&#10;)&#10;&#10;# Fichier JNI wrapper&#10;set(JNI_WRAPPER_SOURCES&#10;    wristband_jni.cpp&#10;)&#10;&#10;# Créer la bibliothèque partagée unique pour Android&#10;add_library(&#10;    wristband_native&#10;    SHARED&#10;    ${WRISTBAND_SOURCES}&#10;    ${JNI_WRAPPER_SOURCES}&#10;)&#10;&#10;# Configurer les propriétés de compilation&#10;set_target_properties(wristband_native PROPERTIES&#10;    POSITION_INDEPENDENT_CODE ON&#10;    CXX_STANDARD 17&#10;    CXX_STANDARD_REQUIRED ON&#10;)&#10;&#10;# Lier avec les bibliothèques Android nécessaires&#10;find_library(log-lib log)&#10;&#10;target_link_libraries(&#10;    wristband_native&#10;    ${log-lib}&#10;)&#10;&#10;# Définir les flags de compilation&#10;target_compile_definitions(wristband_native PRIVATE&#10;    ANDROID_BUILD=1&#10;    _GNU_SOURCE=1&#10;)&#10;&#10;# Optimisations et flags spécifiques&#10;target_compile_options(wristband_native PRIVATE&#10;    -Wall&#10;    -Wextra&#10;    -fPIC&#10;)&#10;&#10;# Optimisations pour la release&#10;if(CMAKE_BUILD_TYPE STREQUAL &quot;Release&quot;)&#10;    target_compile_options(wristband_native PRIVATE -O3 -DNDEBUG)&#10;else()&#10;    target_compile_options(wristband_native PRIVATE -O0 -g)&#10;endif()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/wristband_jni.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/wristband_jni.cpp" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="#include &lt;jni.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;android/log.h&gt;&#10;#include &quot;wristband_obje/control.h&quot;&#10;#include &quot;wristband_obje/Event.h&quot;&#10;&#10;#define LOG_TAG &quot;WristbandJNI&quot;&#10;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)&#10;#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)&#10;&#10;/**&#10; * Encapsule les données avec le protocole attendu par le device :&#10; * - Header: $$ (2 octets)&#10; * - Données: payload (taille variable)&#10; * - Parity: XOR de tous les octets de données (1 octet)&#10; * - Footer: 0xFF 0xAB 0xCD 0xEF (4 octets)&#10; */&#10;std::vector&lt;uint8_t&gt; encapsulateMessage(const std::vector&lt;uint8_t&gt;&amp; payload) {&#10;    std::vector&lt;uint8_t&gt; encapsulated;&#10;&#10;    // Réserver la taille nécessaire pour éviter les réallocations&#10;    encapsulated.reserve(payload.size() + 7); // 2 (header) + 1 (parity) + 4 (footer)&#10;&#10;    // 1. Ajouter le header '$$'&#10;    encapsulated.push_back('$');&#10;    encapsulated.push_back('$');&#10;&#10;    // 2. Ajouter les données&#10;    encapsulated.insert(encapsulated.end(), payload.begin(), payload.end());&#10;&#10;    // 3. Calculer et ajouter la parité (XOR de tous les octets de données)&#10;    uint8_t parity = 0;&#10;    for (uint8_t byte : payload) {&#10;        parity ^= byte;&#10;    }&#10;    encapsulated.push_back(parity);&#10;&#10;    // 4. Ajouter le footer 0xFF 0xAB 0xCD 0xEF&#10;    encapsulated.push_back(0xFF);&#10;    encapsulated.push_back(0xAB);&#10;    encapsulated.push_back(0xCD);&#10;    encapsulated.push_back(0xEF);&#10;&#10;    LOGI(&quot;Message encapsulé: payload=%zu octets, total=%zu octets, parity=0x%02X&quot;,&#10;         payload.size(), encapsulated.size(), parity);&#10;&#10;    return encapsulated;&#10;}&#10;&#10;extern &quot;C&quot; {&#10;&#10;JNIEXPORT jbyteArray JNICALL&#10;Java_com_example_apptest2_wristband_WristbandNative_createHelloMessage(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jstring sourceVersion,&#10;        jstring sourceName,&#10;        jint destinationMask) {&#10;&#10;    try {&#10;        LOGI(&quot;Début création Hello message&quot;);&#10;&#10;        const char *version = env-&gt;GetStringUTFChars(sourceVersion, nullptr);&#10;        const char *name = env-&gt;GetStringUTFChars(sourceName, nullptr);&#10;&#10;        LOGI(&quot;Version: %s, Name: %s, Mask: %d&quot;, version, name, destinationMask);&#10;&#10;        // Créer un message Hello avec la librairie wristband_objects&#10;        Hello hello(version, name, static_cast&lt;uint16_t&gt;(destinationMask));&#10;        std::vector&lt;uint8_t&gt; payload = hello.encode();&#10;&#10;        LOGI(&quot;Hello payload créé, taille: %zu octets&quot;, payload.size());&#10;&#10;        // Libérer les chaînes JNI&#10;        env-&gt;ReleaseStringUTFChars(sourceVersion, version);&#10;        env-&gt;ReleaseStringUTFChars(sourceName, name);&#10;&#10;        // Encapsuler le message avec le protocole&#10;        std::vector&lt;uint8_t&gt; frame = encapsulateMessage(payload);&#10;&#10;        LOGI(&quot;Hello message encapsulé, taille totale: %zu octets&quot;, frame.size());&#10;&#10;        // Convertir le std::vector en jbyteArray&#10;        jbyteArray result = env-&gt;NewByteArray(frame.size());&#10;        env-&gt;SetByteArrayRegion(result, 0, frame.size(), reinterpret_cast&lt;const jbyte*&gt;(frame.data()));&#10;&#10;        return result;&#10;    } catch (const std::exception&amp; e) {&#10;        LOGE(&quot;Exception dans createHelloMessage: %s&quot;, e.what());&#10;        return nullptr;&#10;    } catch (...) {&#10;        LOGE(&quot;Exception inconnue dans createHelloMessage&quot;);&#10;        return nullptr;&#10;    }&#10;}&#10;&#10;JNIEXPORT jbyteArray JNICALL&#10;Java_com_example_apptest2_wristband_WristbandNative_createEventMessage(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jint style,&#10;        jint red,&#10;        jint green,&#10;        jint blue) {&#10;&#10;    try {&#10;        LOGI(&quot;Début création Event message - Style: %d, RGB: %d,%d,%d&quot;, style, red, green, blue);&#10;&#10;        // Créer un événement simple avec la librairie wristband_objects&#10;        Event event;&#10;&#10;        // Créer un effet avec le style demandé&#10;        Style eventStyle = static_cast&lt;Style&gt;(style);&#10;        uint8_t color[NB_COLORS_V0_0] = {&#10;            static_cast&lt;uint8_t&gt;(red),   // Rouge&#10;            static_cast&lt;uint8_t&gt;(green), // Vert&#10;            static_cast&lt;uint8_t&gt;(blue),  // Bleu&#10;            0,                           // Blanc&#10;            0                            // Vibration&#10;        };&#10;&#10;        LOGI(&quot;Création Effect avec style %d&quot;, static_cast&lt;int&gt;(eventStyle));&#10;        Effect effect(eventStyle, 1, 100, 255, color);&#10;        event.effect = effect;&#10;&#10;        // Configurer des valeurs par défaut pour les autres champs requis&#10;        event.mask = 0xFF;&#10;        event.target_uid = 0;&#10;&#10;        // Temps relatifs par défaut (événement immédiat)&#10;        LOGI(&quot;Configuration des temps&quot;);&#10;        Relative_time_ms startTime(0);&#10;        Relative_time_ms stopTime(1000);&#10;        event.r_start_event_ms = startTime;&#10;        event.r_stop_event_ms = stopTime;&#10;&#10;        // Localisation par défaut (pas de GPS)&#10;        LOGI(&quot;Configuration localisation&quot;);&#10;        Localization localization;&#10;        event.localization = localization;&#10;&#10;        // Layer par défaut&#10;        LOGI(&quot;Configuration layer&quot;);&#10;        Layer layer(0, 255, Normal);&#10;        event.layer = layer;&#10;&#10;        // Encoder la trame&#10;        LOGI(&quot;Encodage de l'événement&quot;);&#10;        std::vector&lt;uint8_t&gt; payload = event.encode();&#10;&#10;        LOGI(&quot;Event payload créé, taille: %zu octets&quot;, payload.size());&#10;&#10;        // Log des premiers octets du payload pour debug&#10;        if (payload.size() &gt; 0) {&#10;            std::string hexStr;&#10;            for (size_t i = 0; i &lt; std::min(payload.size(), size_t(16)); i++) {&#10;                char buf[8];&#10;                snprintf(buf, sizeof(buf), &quot;0x%02x &quot;, payload[i]);&#10;                hexStr += buf;&#10;            }&#10;            LOGI(&quot;Premiers octets payload: %s&quot;, hexStr.c_str());&#10;        }&#10;&#10;        // Encapsuler le message avec le protocole&#10;        std::vector&lt;uint8_t&gt; frame = encapsulateMessage(payload);&#10;&#10;        LOGI(&quot;Event message encapsulé, taille totale: %zu octets&quot;, frame.size());&#10;&#10;        // Log des premiers octets de la trame complète pour debug&#10;        if (frame.size() &gt; 0) {&#10;            std::string hexStr;&#10;            for (size_t i = 0; i &lt; std::min(frame.size(), size_t(16)); i++) {&#10;                char buf[8];&#10;                snprintf(buf, sizeof(buf), &quot;0x%02x &quot;, frame[i]);&#10;                hexStr += buf;&#10;            }&#10;            LOGI(&quot;Premiers octets trame: %s&quot;, hexStr.c_str());&#10;        }&#10;&#10;        // Convertir en jbyteArray&#10;        jbyteArray result = env-&gt;NewByteArray(frame.size());&#10;        env-&gt;SetByteArrayRegion(result, 0, frame.size(), reinterpret_cast&lt;const jbyte*&gt;(frame.data()));&#10;&#10;        return result;&#10;    } catch (const std::exception&amp; e) {&#10;        LOGE(&quot;Exception dans createEventMessage: %s&quot;, e.what());&#10;        return nullptr;&#10;    } catch (...) {&#10;        LOGE(&quot;Exception inconnue dans createEventMessage&quot;);&#10;        return nullptr;&#10;    }&#10;}&#10;&#10;JNIEXPORT jbyteArray JNICALL&#10;Java_com_example_apptest2_wristband_WristbandNative_createCommandMessage(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jint command,&#10;        jint param1,&#10;        jint param2) {&#10;&#10;    try {&#10;        LOGI(&quot;Début création Command message - Cmd: %d, Param1: %d, Param2: %d&quot;, command, param1, param2);&#10;&#10;        // Créer une commande avec la librairie wristband_objects&#10;        WB_Command cmd;&#10;&#10;        // Convertir la commande (vous devrez adapter selon votre enum WB_Command_type)&#10;        WB_Command_type commandType = static_cast&lt;WB_Command_type&gt;(command);&#10;&#10;        cmd.set_command(commandType, static_cast&lt;uint32_t&gt;(param1), static_cast&lt;uint32_t&gt;(param2));&#10;&#10;        // Encoder la trame&#10;        std::vector&lt;uint8_t&gt; payload = cmd.encode();&#10;&#10;        LOGI(&quot;Command payload créé, taille: %zu octets&quot;, payload.size());&#10;&#10;        // Encapsuler le message avec le protocole&#10;        std::vector&lt;uint8_t&gt; frame = encapsulateMessage(payload);&#10;&#10;        LOGI(&quot;Command message encapsulé, taille totale: %zu octets&quot;, frame.size());&#10;&#10;        // Convertir en jbyteArray&#10;        jbyteArray result = env-&gt;NewByteArray(frame.size());&#10;        env-&gt;SetByteArrayRegion(result, 0, frame.size(), reinterpret_cast&lt;const jbyte*&gt;(frame.data()));&#10;&#10;        return result;&#10;    } catch (const std::exception&amp; e) {&#10;        LOGE(&quot;Exception dans createCommandMessage: %s&quot;, e.what());&#10;        return nullptr;&#10;    } catch (...) {&#10;        LOGE(&quot;Exception inconnue dans createCommandMessage&quot;);&#10;        return nullptr;&#10;    }&#10;}&#10;&#10;JNIEXPORT jboolean JNICALL&#10;Java_com_example_apptest2_wristband_WristbandNative_validateFrame(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jbyteArray frame) {&#10;&#10;    jsize frameSize = env-&gt;GetArrayLength(frame);&#10;    jbyte* frameData = env-&gt;GetByteArrayElements(frame, nullptr);&#10;&#10;    // Convertir en std::vector&#10;    std::vector&lt;uint8_t&gt; frameVector(&#10;        reinterpret_cast&lt;uint8_t*&gt;(frameData),&#10;        reinterpret_cast&lt;uint8_t*&gt;(frameData) + frameSize&#10;    );&#10;&#10;    // Validation basique - vérifier que la taille est raisonnable&#10;    bool isValid = frameSize &gt; 2 &amp;&amp; frameSize &lt;= 256;&#10;&#10;    // Libérer les ressources JNI&#10;    env-&gt;ReleaseByteArrayElements(frame, frameData, JNI_ABORT);&#10;&#10;    return static_cast&lt;jboolean&gt;(isValid);&#10;}&#10;&#10;JNIEXPORT jstring JNICALL&#10;Java_com_example_apptest2_wristband_WristbandNative_getFrameInfo(&#10;        JNIEnv *env,&#10;        jobject /* this */,&#10;        jbyteArray frame) {&#10;&#10;    jsize frameSize = env-&gt;GetArrayLength(frame);&#10;    jbyte* frameData = env-&gt;GetByteArrayElements(frame, nullptr);&#10;&#10;    // Convertir en std::vector&#10;    std::vector&lt;uint8_t&gt; frameVector(&#10;        reinterpret_cast&lt;uint8_t*&gt;(frameData),&#10;        reinterpret_cast&lt;uint8_t*&gt;(frameData) + frameSize&#10;    );&#10;&#10;    // Créer une chaîne d'information sur la trame&#10;    std::string info = &quot;Taille: &quot; + std::to_string(frameSize) + &quot; octets&quot;;&#10;&#10;    if (frameSize &gt;= 2) {&#10;        uint16_t identifier = static_cast&lt;uint16_t&gt;(frameData[0]) |&#10;                             (static_cast&lt;uint16_t&gt;(frameData[1]) &lt;&lt; 8);&#10;        info += &quot;, ID: 0x&quot; + std::to_string(identifier);&#10;    }&#10;&#10;    // Libérer les ressources JNI&#10;    env-&gt;ReleaseByteArrayElements(frame, frameData, JNI_ABORT);&#10;&#10;    return env-&gt;NewStringUTF(info.c_str());&#10;}&#10;&#10;} // extern &quot;C&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/wristband_obje/control.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/wristband_obje/control.cpp" />
              <option name="originalContent" value="#include &quot;control.h&quot;&#10;#include &lt;iomanip&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;ctype.h&gt;&#10;#include &lt;vector&gt;&#10;#include &quot;Identifiers.h&quot;&#10;#include &quot;BufferUtils.h&quot;&#10;&#10;&#10;&#10;&#10;&#10;Hello::Hello()&#10;        : source_version{0}, source_name{0}, destination_mask(0){}&#10;&#10;Hello::~Hello(){}&#10;&#10;Hello::Hello(const char* source_version, const char* source_name, uint16_t destination_mask)&#10;        : destination_mask(destination_mask){&#10;    // Ensure that the source version is copied correctly and is null-terminated.&#10;    std::memset(this-&gt;source_version, 0, sizeof(this-&gt;source_version)); // Clear the array&#10;    std::memcpy(this-&gt;source_version, source_version, std::min(std::strlen(source_version), sizeof(this-&gt;source_version)));&#10;&#10;    // Ensure that the source name is copied correctly and is null-terminated.&#10;    std::memset(this-&gt;source_name, 0, sizeof(this-&gt;source_name)); // Clear the array&#10;    std::memcpy(this-&gt;source_name, source_name, std::min(std::strlen(source_name), sizeof(this-&gt;source_name)));&#10;}&#10;&#10;void Hello::reset() {&#10;    std::memset(source_version, 0, sizeof(source_version));&#10;    std::memset(source_name, 0, sizeof(source_name));&#10;    destination_mask = 0;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; Hello::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = HELLO_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append_array(source_version, 8);&#10;    builder.append_array(source_name, 32);&#10;    builder.append(destination_mask);&#10;&#10;    return buffer;&#10;}&#10;&#10;&#10;Hello::Hello(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();  // Initialise les champs à 0&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != HELLO_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_ARRAY_OR_RESET(source_version, 8);&#10;    READ_ARRAY_OR_RESET(source_name, 32);&#10;    READ_OR_RESET(destination_mask);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hello&amp; rt){&#10;    os &lt;&lt; &quot;Hello message! - &quot;;&#10;    os &lt;&lt; &quot;From: &quot;;&#10;    for (int i = 0; i &lt; 32; i++) {&#10;        os &lt;&lt; rt.source_name[i];&#10;    }&#10;    os &lt;&lt; &quot; - Version: &quot;;&#10;    for (int i = 0; i &lt; 8; i++) {&#10;        os &lt;&lt; rt.source_version[i];&#10;    }&#10;    return os;&#10;}&#10;&#10;std::string Hello::toString() const {&#10;    std::stringstream ss;&#10;    ss &lt;&lt; *this;&#10;    return ss.str();&#10;}&#10;&#10;Comm_test_30B::Comm_test_30B()&#10;        : index(0){}&#10;&#10;Comm_test_30B::~Comm_test_30B(){}&#10;&#10;void Comm_test_30B::set_index(uint16_t index){&#10;    this-&gt;index = index;&#10;}&#10;&#10;uint16_t Comm_test_30B::get_index(){&#10;    return index;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; Comm_test_30B::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMM_TEST_30B_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(index);&#10;&#10;    // Remplissage jusqu'à 30 octets (identifier + index = 4 octets ⇒ 26 restants)&#10;    for (int i = 0; i &lt; 26; i++) {&#10;        buffer.push_back(0x55);&#10;        builder.size++; // pour rester cohérent avec le compteur interne&#10;    }&#10;&#10;    index++; // Incrément après envoi&#10;&#10;    return buffer;&#10;}&#10;&#10;Comm_test_30B::Comm_test_30B(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMM_TEST_30B_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(index);&#10;&#10;    // Vérifie que la taille est exactement de 30 octets&#10;    if (buffer.size() != 30) {&#10;        reset();&#10;        return;&#10;    }&#10;}&#10;&#10;&#10;&#10;Comm_test_95B::Comm_test_95B()&#10;        : index(0){}&#10;&#10;Comm_test_95B::~Comm_test_95B(){}&#10;&#10;void Comm_test_95B::set_index(uint16_t index){&#10;    this-&gt;index = index;&#10;}&#10;&#10;uint16_t Comm_test_95B::get_index(){&#10;    return index;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; Comm_test_95B::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMM_TEST_95B_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(index);&#10;&#10;    // Ajoute 91 octets contenant la valeur de l'index (total = 2 + 2 + 91 = 95)&#10;    for (int i = 0; i &lt; 91; i++) {&#10;        buffer.push_back(static_cast&lt;uint8_t&gt;(index));&#10;        builder.size++;&#10;    }&#10;&#10;    index++; // Incrément après émission&#10;    return buffer;&#10;}&#10;&#10;Comm_test_95B::Comm_test_95B(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMM_TEST_95B_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(index);&#10;&#10;    // Vérifie que la trame est bien de 95 octets&#10;    if (buffer.size() != 95) {&#10;        reset();&#10;        return;&#10;    }&#10;}&#10;WB_Command::WB_Command()&#10;        : command(WB_Command_type::No_command){}&#10;&#10;WB_Command::WB_Command(WB_Command_type command)&#10;        : command(command){&#10;    parameter1 = 0;&#10;    parameter2 = 0;&#10;&#10;}&#10;&#10;WB_Command::WB_Command(WB_Command_type command, uint32_t param1, uint32_t param2)&#10;        : command(command), parameter1(param1), parameter2(param2){}&#10;&#10;WB_Command::~WB_Command(){}&#10;&#10;void WB_Command::set_command(WB_Command_type command){&#10;    this-&gt;command = command;&#10;}&#10;&#10;void WB_Command::set_command(WB_Command_type command, uint32_t param1, uint32_t param2){&#10;    this-&gt;command = command;&#10;    this-&gt;parameter1 = param1;&#10;    this-&gt;parameter2 = param2;&#10;}   &#10;&#10;void WB_Command::get_parameters(uint32_t&amp; param1, uint32_t&amp; param2){&#10;    param1 = parameter1;&#10;    param2 = parameter2;&#10;}&#10;&#10;WB_Command_type WB_Command::get_command(){&#10;    return command;&#10;}&#10;&#10;void WB_Command::reset() {&#10;    command = WB_Command_type::No_command;&#10;    parameter1 = 0;&#10;    parameter2 = 0;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; WB_Command::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMMAND_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(command);&#10;    builder.append(parameter1);&#10;    builder.append(parameter2);&#10;&#10;    return buffer;&#10;}&#10;&#10;WB_Command::WB_Command(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMMAND_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(command);&#10;    READ_OR_RESET(parameter1);&#10;    READ_OR_RESET(parameter2);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;WB_Command_short::WB_Command_short()&#10;        : command(WB_Command_short_type::No_command_short){}&#10;&#10;WB_Command_short::WB_Command_short(WB_Command_short_type command, uint16_t param1)&#10;        : command(command), parameter1(param1){}&#10;&#10;WB_Command_short::~WB_Command_short(){} &#10;&#10;void WB_Command_short::set_command(WB_Command_short_type command){&#10;    this-&gt;command = command;&#10;}&#10;&#10;void WB_Command_short::set_command(WB_Command_short_type command, uint16_t param1){&#10;    this-&gt;command = command;&#10;    this-&gt;parameter1 = param1;&#10;}&#10;&#10;WB_Command_short_type WB_Command_short::get_command(){&#10;    return command;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; WB_Command_short::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMMAND_SHORT_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(command);&#10;    builder.append(parameter1);&#10;&#10;    return buffer;&#10;}&#10;&#10;void WB_Command_short::reset() {&#10;    command = WB_Command_short_type::No_command_short;&#10;    parameter1 = 0;&#10;}&#10;&#10;WB_Command_short::WB_Command_short(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMMAND_SHORT_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(command);&#10;    READ_OR_RESET(parameter1);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;uint16_t WB_Command_short::get_parameter(){&#10;    return parameter1;&#10;}&#10;&#10;WB_Command_long::WB_Command_long()&#10;        : command(WB_Command_long_type::No_command_long){}&#10;&#10;WB_Command_long::WB_Command_long(WB_Command_long_type command, uint64_t param1, uint64_t param2, uint64_t param3, uint64_t param4)&#10;        : command(command), parameter1(param1), parameter2(param2), parameter3(param3), parameter4(param4){}&#10;&#10;WB_Command_long::~WB_Command_long(){}&#10;&#10;void WB_Command_long::set_command(WB_Command_long_type command){&#10;    this-&gt;command = command;&#10;}&#10;&#10;void WB_Command_long::set_command(WB_Command_long_type command, uint64_t param1, uint64_t param2, uint64_t param3, uint64_t param4){&#10;    this-&gt;command = command;&#10;    this-&gt;parameter1 = param1;&#10;    this-&gt;parameter2 = param2;&#10;    this-&gt;parameter3 = param3;&#10;    this-&gt;parameter4 = param4;&#10;}&#10;&#10;WB_Command_long_type WB_Command_long::get_command(){&#10;    return command;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; WB_Command_long::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMMAND_LONG_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(command);&#10;    builder.append(parameter1);&#10;    builder.append(parameter2);&#10;    builder.append(parameter3);&#10;    builder.append(parameter4);&#10;&#10;    return buffer;&#10;}&#10;WB_Command_long::WB_Command_long(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMMAND_LONG_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(command);&#10;    READ_OR_RESET(parameter1);&#10;    READ_OR_RESET(parameter2);&#10;    READ_OR_RESET(parameter3);&#10;    READ_OR_RESET(parameter4);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;void WB_Command_long::reset() {&#10;    command = WB_Command_long_type::No_command_long;&#10;    parameter1 = 0;&#10;    parameter2 = 0;&#10;    parameter3 = 0;&#10;    parameter4 = 0;&#10;}&#10;&#10;void WB_Command_long::get_parameters(uint64_t&amp; param1, uint64_t&amp; param2, uint64_t&amp; param3, uint64_t&amp; param4){&#10;    param1 = parameter1;&#10;    param2 = parameter2;&#10;    param3 = parameter3;&#10;    param4 = parameter4;&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="#include &quot;control.h&quot;&#10;#include &lt;iomanip&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;ctype.h&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;sstream&gt;&#10;#include &quot;Identifiers.h&quot;&#10;#include &quot;BufferUtils.h&quot;&#10;&#10;&#10;&#10;&#10;&#10;Hello::Hello()&#10;        : source_version{0}, source_name{0}, destination_mask(0){}&#10;&#10;Hello::~Hello(){}&#10;&#10;Hello::Hello(const char* source_version, const char* source_name, uint16_t destination_mask)&#10;        : destination_mask(destination_mask){&#10;    // Ensure that the source version is copied correctly and is null-terminated.&#10;    std::memset(this-&gt;source_version, 0, sizeof(this-&gt;source_version)); // Clear the array&#10;    std::memcpy(this-&gt;source_version, source_version, std::min(std::strlen(source_version), sizeof(this-&gt;source_version)));&#10;&#10;    // Ensure that the source name is copied correctly and is null-terminated.&#10;    std::memset(this-&gt;source_name, 0, sizeof(this-&gt;source_name)); // Clear the array&#10;    std::memcpy(this-&gt;source_name, source_name, std::min(std::strlen(source_name), sizeof(this-&gt;source_name)));&#10;}&#10;&#10;void Hello::reset() {&#10;    std::memset(source_version, 0, sizeof(source_version));&#10;    std::memset(source_name, 0, sizeof(source_name));&#10;    destination_mask = 0;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; Hello::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = HELLO_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append_array(source_version, 8);&#10;    builder.append_array(source_name, 32);&#10;    builder.append(destination_mask);&#10;&#10;    return buffer;&#10;}&#10;&#10;&#10;Hello::Hello(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();  // Initialise les champs à 0&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != HELLO_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_ARRAY_OR_RESET(source_version, 8);&#10;    READ_ARRAY_OR_RESET(source_name, 32);&#10;    READ_OR_RESET(destination_mask);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hello&amp; rt){&#10;    os &lt;&lt; &quot;Hello message! - &quot;;&#10;    os &lt;&lt; &quot;From: &quot;;&#10;    for (int i = 0; i &lt; 32; i++) {&#10;        os &lt;&lt; rt.source_name[i];&#10;    }&#10;    os &lt;&lt; &quot; - Version: &quot;;&#10;    for (int i = 0; i &lt; 8; i++) {&#10;        os &lt;&lt; rt.source_version[i];&#10;    }&#10;    return os;&#10;}&#10;&#10;std::string Hello::toString() const {&#10;    std::stringstream ss;&#10;    ss &lt;&lt; *this;&#10;    return ss.str();&#10;}&#10;&#10;Comm_test_30B::Comm_test_30B()&#10;        : index(0){}&#10;&#10;Comm_test_30B::~Comm_test_30B(){}&#10;&#10;void Comm_test_30B::set_index(uint16_t index){&#10;    this-&gt;index = index;&#10;}&#10;&#10;uint16_t Comm_test_30B::get_index(){&#10;    return index;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; Comm_test_30B::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMM_TEST_30B_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(index);&#10;&#10;    // Remplissage jusqu'à 30 octets (identifier + index = 4 octets ⇒ 26 restants)&#10;    for (int i = 0; i &lt; 26; i++) {&#10;        buffer.push_back(0x55);&#10;        builder.size++; // pour rester cohérent avec le compteur interne&#10;    }&#10;&#10;    index++; // Incrément après envoi&#10;&#10;    return buffer;&#10;}&#10;&#10;Comm_test_30B::Comm_test_30B(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMM_TEST_30B_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(index);&#10;&#10;    // Vérifie que la taille est exactement de 30 octets&#10;    if (buffer.size() != 30) {&#10;        reset();&#10;        return;&#10;    }&#10;}&#10;&#10;&#10;&#10;Comm_test_95B::Comm_test_95B()&#10;        : index(0){}&#10;&#10;Comm_test_95B::~Comm_test_95B(){}&#10;&#10;void Comm_test_95B::set_index(uint16_t index){&#10;    this-&gt;index = index;&#10;}&#10;&#10;uint16_t Comm_test_95B::get_index(){&#10;    return index;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; Comm_test_95B::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMM_TEST_95B_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(index);&#10;&#10;    // Ajoute 91 octets contenant la valeur de l'index (total = 2 + 2 + 91 = 95)&#10;    for (int i = 0; i &lt; 91; i++) {&#10;        buffer.push_back(static_cast&lt;uint8_t&gt;(index));&#10;        builder.size++;&#10;    }&#10;&#10;    index++; // Incrément après émission&#10;    return buffer;&#10;}&#10;&#10;Comm_test_95B::Comm_test_95B(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMM_TEST_95B_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(index);&#10;&#10;    // Vérifie que la trame est bien de 95 octets&#10;    if (buffer.size() != 95) {&#10;        reset();&#10;        return;&#10;    }&#10;}&#10;WB_Command::WB_Command()&#10;        : command(WB_Command_type::No_command){}&#10;&#10;WB_Command::WB_Command(WB_Command_type command)&#10;        : command(command){&#10;    parameter1 = 0;&#10;    parameter2 = 0;&#10;&#10;}&#10;&#10;WB_Command::WB_Command(WB_Command_type command, uint32_t param1, uint32_t param2)&#10;        : command(command), parameter1(param1), parameter2(param2){}&#10;&#10;WB_Command::~WB_Command(){}&#10;&#10;void WB_Command::set_command(WB_Command_type command){&#10;    this-&gt;command = command;&#10;}&#10;&#10;void WB_Command::set_command(WB_Command_type command, uint32_t param1, uint32_t param2){&#10;    this-&gt;command = command;&#10;    this-&gt;parameter1 = param1;&#10;    this-&gt;parameter2 = param2;&#10;}   &#10;&#10;void WB_Command::get_parameters(uint32_t&amp; param1, uint32_t&amp; param2){&#10;    param1 = parameter1;&#10;    param2 = parameter2;&#10;}&#10;&#10;WB_Command_type WB_Command::get_command(){&#10;    return command;&#10;}&#10;&#10;void WB_Command::reset() {&#10;    command = WB_Command_type::No_command;&#10;    parameter1 = 0;&#10;    parameter2 = 0;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; WB_Command::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMMAND_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(command);&#10;    builder.append(parameter1);&#10;    builder.append(parameter2);&#10;&#10;    return buffer;&#10;}&#10;&#10;WB_Command::WB_Command(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMMAND_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(command);&#10;    READ_OR_RESET(parameter1);&#10;    READ_OR_RESET(parameter2);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;WB_Command_short::WB_Command_short()&#10;        : command(WB_Command_short_type::No_command_short){}&#10;&#10;WB_Command_short::WB_Command_short(WB_Command_short_type command, uint16_t param1)&#10;        : command(command), parameter1(param1){}&#10;&#10;WB_Command_short::~WB_Command_short(){} &#10;&#10;void WB_Command_short::set_command(WB_Command_short_type command){&#10;    this-&gt;command = command;&#10;}&#10;&#10;void WB_Command_short::set_command(WB_Command_short_type command, uint16_t param1){&#10;    this-&gt;command = command;&#10;    this-&gt;parameter1 = param1;&#10;}&#10;&#10;WB_Command_short_type WB_Command_short::get_command(){&#10;    return command;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; WB_Command_short::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMMAND_SHORT_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(command);&#10;    builder.append(parameter1);&#10;&#10;    return buffer;&#10;}&#10;&#10;void WB_Command_short::reset() {&#10;    command = WB_Command_short_type::No_command_short;&#10;    parameter1 = 0;&#10;}&#10;&#10;WB_Command_short::WB_Command_short(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMMAND_SHORT_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(command);&#10;    READ_OR_RESET(parameter1);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;uint16_t WB_Command_short::get_parameter(){&#10;    return parameter1;&#10;}&#10;&#10;WB_Command_long::WB_Command_long()&#10;        : command(WB_Command_long_type::No_command_long){}&#10;&#10;WB_Command_long::WB_Command_long(WB_Command_long_type command, uint64_t param1, uint64_t param2, uint64_t param3, uint64_t param4)&#10;        : command(command), parameter1(param1), parameter2(param2), parameter3(param3), parameter4(param4){}&#10;&#10;WB_Command_long::~WB_Command_long(){}&#10;&#10;void WB_Command_long::set_command(WB_Command_long_type command){&#10;    this-&gt;command = command;&#10;}&#10;&#10;void WB_Command_long::set_command(WB_Command_long_type command, uint64_t param1, uint64_t param2, uint64_t param3, uint64_t param4){&#10;    this-&gt;command = command;&#10;    this-&gt;parameter1 = param1;&#10;    this-&gt;parameter2 = param2;&#10;    this-&gt;parameter3 = param3;&#10;    this-&gt;parameter4 = param4;&#10;}&#10;&#10;WB_Command_long_type WB_Command_long::get_command(){&#10;    return command;&#10;}&#10;&#10;std::vector&lt;uint8_t&gt; WB_Command_long::encode() {&#10;    std::vector&lt;uint8_t&gt; buffer;&#10;    BufferBuilder builder(buffer);&#10;&#10;    uint16_t identifier = COMMAND_LONG_MSG_ID;&#10;    builder.append(identifier);&#10;    builder.append(command);&#10;    builder.append(parameter1);&#10;    builder.append(parameter2);&#10;    builder.append(parameter3);&#10;    builder.append(parameter4);&#10;&#10;    return buffer;&#10;}&#10;WB_Command_long::WB_Command_long(std::vector&lt;uint8_t&gt; buffer) {&#10;    BufferReader reader(buffer);&#10;    reset();&#10;&#10;    uint16_t inputIdentifier;&#10;    READ_OR_RESET(inputIdentifier);&#10;&#10;    if (inputIdentifier != COMMAND_LONG_MSG_ID) {&#10;        reset();&#10;        return;&#10;    }&#10;&#10;    READ_OR_RESET(command);&#10;    READ_OR_RESET(parameter1);&#10;    READ_OR_RESET(parameter2);&#10;    READ_OR_RESET(parameter3);&#10;    READ_OR_RESET(parameter4);&#10;&#10;    if (!reader.finished()) {&#10;        reset();&#10;    }&#10;}&#10;&#10;void WB_Command_long::reset() {&#10;    command = WB_Command_long_type::No_command_long;&#10;    parameter1 = 0;&#10;    parameter2 = 0;&#10;    parameter3 = 0;&#10;    parameter4 = 0;&#10;}&#10;&#10;void WB_Command_long::get_parameters(uint64_t&amp; param1, uint64_t&amp; param2, uint64_t&amp; param3, uint64_t&amp; param4){&#10;    param1 = parameter1;&#10;    param2 = parameter2;&#10;    param3 = parameter3;&#10;    param4 = parameter4;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/usb/UsbManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/usb/UsbManager.kt" />
              <option name="originalContent" value="package com.example.apptest2.usb&#10;&#10;import android.app.PendingIntent&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.hardware.usb.UsbConstants&#10;import android.hardware.usb.UsbDevice&#10;import android.hardware.usb.UsbManager&#10;import android.util.Log&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;&#10;class UsbCdcManager(private val context: Context) {&#10;&#10;    private val usbManager by lazy { context.getSystemService(Context.USB_SERVICE) as UsbManager }&#10;    private val ACTION_USB_PERMISSION = &quot;com.example.apptest2.USB_PERMISSION&quot;&#10;&#10;    // Nouveau : Stockage des logs pour affichage dans l'UI&#10;    private val _logMessages = mutableListOf&lt;String&gt;()&#10;    val logMessages: List&lt;String&gt; get() = _logMessages.toList()&#10;&#10;    private fun addLog(message: String) {&#10;        val timestamp = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        val logEntry = &quot;[$timestamp] $message&quot;&#10;        _logMessages.add(logEntry)&#10;        Log.d(&quot;UsbCdcManager&quot;, message)&#10;&#10;        // Garder seulement les 50 derniers logs&#10;        if (_logMessages.size &gt; 50) {&#10;            _logMessages.removeAt(0)&#10;        }&#10;    }&#10;&#10;    fun clearLogs() {&#10;        _logMessages.clear()&#10;    }&#10;&#10;    suspend fun sendString(string: String): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                addLog(&quot;=== DÉBUT ENVOI USB ===&quot;)&#10;                addLog(&quot;Tentative d'envoi: $string&quot;)&#10;&#10;                // Lister tous les périphériques connectés&#10;                val allDevices = usbManager.deviceList&#10;                addLog(&quot;Nombre de périphériques USB détectés: ${allDevices.size}&quot;)&#10;&#10;                allDevices.values.forEachIndexed { index, device -&gt;&#10;                    addLog(&quot;Périphérique $index:&quot;)&#10;                    addLog(&quot;  - Nom: ${device.deviceName}&quot;)&#10;                    addLog(&quot;  - Vendor ID: 0x${device.vendorId.toString(16)}&quot;)&#10;                    addLog(&quot;  - Product ID: 0x${device.productId.toString(16)}&quot;)&#10;                    addLog(&quot;  - Nombre d'interfaces: ${device.interfaceCount}&quot;)&#10;                    addLog(&quot;  - Permission accordée: ${usbManager.hasPermission(device)}&quot;)&#10;&#10;                    // Lister toutes les interfaces&#10;                    for (i in 0 until device.interfaceCount) {&#10;                        val intf = device.getInterface(i)&#10;                        addLog(&quot;    Interface $i: class=${intf.interfaceClass}, subclass=${intf.interfaceSubclass}, protocol=${intf.interfaceProtocol}&quot;)&#10;                    }&#10;                }&#10;&#10;                val device = findCdcDevice()&#10;                if (device == null) {&#10;                    addLog(&quot;❌ Aucun périphérique CDC trouvé&quot;)&#10;                    addLog(&quot;Recherchez un périphérique avec interface class 2 (COMM) ou 10 (CDC_DATA)&quot;)&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Périphérique CDC trouvé: ${device.deviceName}&quot;)&#10;&#10;                if (!usbManager.hasPermission(device)) {&#10;                    addLog(&quot;⚠️ Permission requise pour le périphérique&quot;)&#10;                    val hasPermission = requestPermission(device)&#10;                    if (!hasPermission) {&#10;                        addLog(&quot;❌ Permission refusée par l'utilisateur&quot;)&#10;                        return@withContext false&#10;                    }&#10;                    addLog(&quot;✅ Permission accordée&quot;)&#10;                } else {&#10;                    addLog(&quot;✅ Permission déjà accordée&quot;)&#10;                }&#10;&#10;                val connection = usbManager.openDevice(device)&#10;                if (connection == null) {&#10;                    addLog(&quot;❌ Impossible d'ouvrir le périphérique&quot;)&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Connexion au périphérique établie&quot;)&#10;&#10;                // Recherche de l'interface CDC correcte&#10;                val cdcInterface = findCdcInterface(device)&#10;                if (cdcInterface == null) {&#10;                    addLog(&quot;❌ Interface CDC non trouvée&quot;)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Interface CDC trouvée: class=${cdcInterface.interfaceClass}&quot;)&#10;&#10;                val claimResult = connection.claimInterface(cdcInterface, true)&#10;                if (!claimResult) {&#10;                    addLog(&quot;❌ Impossible de revendiquer l'interface&quot;)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Interface revendiquée avec succès&quot;)&#10;&#10;                // Lister tous les endpoints de l'interface&#10;                addLog(&quot;Endpoints disponibles:&quot;)&#10;                for (i in 0 until cdcInterface.endpointCount) {&#10;                    val ep = cdcInterface.getEndpoint(i)&#10;                    val direction = if (ep.direction == UsbConstants.USB_DIR_OUT) &quot;OUT&quot; else &quot;IN&quot;&#10;                    val type = when (ep.type) {&#10;                        UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                        UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                        UsbConstants.USB_ENDPOINT_XFER_CONTROL -&gt; &quot;CONTROL&quot;&#10;                        UsbConstants.USB_ENDPOINT_XFER_ISOC -&gt; &quot;ISOCHRONOUS&quot;&#10;                        else -&gt; &quot;UNKNOWN&quot;&#10;                    }&#10;                    addLog(&quot;  Endpoint $i: $direction, $type, address=0x${ep.address.toString(16)}&quot;)&#10;                }&#10;&#10;                // Recherche du endpoint de sortie - Version améliorée&#10;                addLog(&quot;Recherche endpoint de sortie...&quot;)&#10;&#10;                // D'abord chercher un endpoint BULK OUT (standard CDC)&#10;                var outEndpoint = (0 until cdcInterface.endpointCount).map {&#10;                    cdcInterface.getEndpoint(it)&#10;                }.find {&#10;                    it.direction == UsbConstants.USB_DIR_OUT &amp;&amp;&#10;                    it.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                }&#10;&#10;                // Si pas trouvé, chercher un endpoint INTERRUPT OUT&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;Pas d'endpoint BULK OUT, recherche INTERRUPT OUT...&quot;)&#10;                    outEndpoint = (0 until cdcInterface.endpointCount).map {&#10;                        cdcInterface.getEndpoint(it)&#10;                    }.find {&#10;                        it.direction == UsbConstants.USB_DIR_OUT &amp;&amp;&#10;                        it.type == UsbConstants.USB_ENDPOINT_XFER_INT&#10;                    }&#10;                }&#10;&#10;                // Si toujours pas trouvé, chercher dans toutes les interfaces&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;Recherche endpoint de sortie dans toutes les interfaces...&quot;)&#10;                    for (i in 0 until device.interfaceCount) {&#10;                        val intf = device.getInterface(i)&#10;                        for (j in 0 until intf.endpointCount) {&#10;                            val ep = intf.getEndpoint(j)&#10;                            if (ep.direction == UsbConstants.USB_DIR_OUT) {&#10;                                addLog(&quot;Trouvé endpoint OUT dans interface $i: type=${when(ep.type) {&#10;                                    UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                                    UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                                    UsbConstants.USB_ENDPOINT_XFER_CONTROL -&gt; &quot;CONTROL&quot;&#10;                                    UsbConstants.USB_ENDPOINT_XFER_ISOC -&gt; &quot;ISOCHRONOUS&quot;&#10;                                    else -&gt; &quot;UNKNOWN&quot;&#10;                                }}&quot;)&#10;&#10;                                // Si c'est une interface différente, on doit la revendiquer&#10;                                if (i != cdcInterface.id) {&#10;                                    addLog(&quot;Changement vers interface $i...&quot;)&#10;                                    connection.releaseInterface(cdcInterface)&#10;                                    val newInterface = device.getInterface(i)&#10;                                    val claimResult2 = connection.claimInterface(newInterface, true)&#10;                                    if (!claimResult2) {&#10;                                        addLog(&quot;❌ Impossible de revendiquer l'interface $i&quot;)&#10;                                        continue&#10;                                    }&#10;                                    addLog(&quot;✅ Interface $i revendiquée&quot;)&#10;                                }&#10;                                outEndpoint = ep&#10;                                break&#10;                            }&#10;                        }&#10;                        if (outEndpoint != null) break&#10;                    }&#10;                }&#10;&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;❌ Aucun endpoint de sortie trouvé&quot;)&#10;                    connection.releaseInterface(cdcInterface)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                val endpointType = when(outEndpoint.type) {&#10;                    UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_CONTROL -&gt; &quot;CONTROL&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_ISOC -&gt; &quot;ISOCHRONOUS&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;                addLog(&quot;✅ Endpoint de sortie trouvé: $endpointType, address=0x${outEndpoint.address.toString(16)}&quot;)&#10;&#10;                val bytes = string.toByteArray()&#10;                addLog(&quot;Envoi de ${bytes.size} bytes: ${bytes.joinToString(&quot; &quot;) { &quot;0x%02x&quot;.format(it) }}&quot;)&#10;&#10;                // Utiliser la méthode appropriée selon le type d'endpoint&#10;                val result = if (outEndpoint.type == UsbConstants.USB_ENDPOINT_XFER_BULK) {&#10;                    connection.bulkTransfer(outEndpoint, bytes, bytes.size, 5000)&#10;                } else {&#10;                    // Pour les endpoints INTERRUPT, utiliser controlTransfer ou bulkTransfer selon le périphérique&#10;                    addLog(&quot;Utilisation d'INTERRUPT endpoint...&quot;)&#10;                    connection.bulkTransfer(outEndpoint, bytes, bytes.size, 5000)&#10;                }&#10;&#10;                val success = result &gt;= 0&#10;                if (success) {&#10;                    addLog(&quot;✅ Données envoyées avec succès: $result bytes&quot;)&#10;                } else {&#10;                    addLog(&quot;❌ Erreur lors de l'envoi: code=$result&quot;)&#10;                    when (result) {&#10;                        -1 -&gt; addLog(&quot;Erreur générale ou timeout&quot;)&#10;                        -2 -&gt; addLog(&quot;Erreur de type ou paramètre invalide&quot;)&#10;                        else -&gt; addLog(&quot;Code d'erreur inconnu: $result&quot;)&#10;                    }&#10;                }&#10;&#10;                connection.releaseInterface(cdcInterface)&#10;                connection.close()&#10;                addLog(&quot;=== FIN ENVOI USB ===&quot;)&#10;                return@withContext success&#10;            } catch (e: Exception) {&#10;                addLog(&quot;❌ Exception lors de l'envoi USB: ${e.message}&quot;)&#10;                return@withContext false&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun requestPermission(device: UsbDevice): Boolean = suspendCancellableCoroutine { continuation -&gt;&#10;        val permissionIntent = PendingIntent.getBroadcast(&#10;            context, 0, Intent(ACTION_USB_PERMISSION),&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val usbReceiver = object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context, intent: Intent) {&#10;                context.unregisterReceiver(this)&#10;                if (ACTION_USB_PERMISSION == intent.action) {&#10;                    val granted = intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)&#10;                    continuation.resume(granted)&#10;                }&#10;            }&#10;        }&#10;&#10;        context.registerReceiver(&#10;            usbReceiver,&#10;            IntentFilter(ACTION_USB_PERMISSION),&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) {&#10;                Context.RECEIVER_NOT_EXPORTED&#10;            } else {&#10;                0&#10;            }&#10;        )&#10;        usbManager.requestPermission(device, permissionIntent)&#10;&#10;        continuation.invokeOnCancellation {&#10;            try {&#10;                context.unregisterReceiver(usbReceiver)&#10;            } catch (_: Exception) {&#10;                // Receiver already unregistered&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun findCdcDevice(): UsbDevice? {&#10;        val devices = usbManager.deviceList.values&#10;        Log.d(&quot;UsbCdcManager&quot;, &quot;=== RECHERCHE PÉRIPHÉRIQUE CDC ===&quot;)&#10;&#10;        // D'abord, essayer de trouver un vrai périphérique CDC&#10;        var cdcDevice = devices.find { device -&gt;&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Vérification périphérique: ${device.deviceName}&quot;)&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;  Vendor ID: 0x${device.vendorId.toString(16)}&quot;)&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;  Product ID: 0x${device.productId.toString(16)}&quot;)&#10;&#10;            // Recherche d'interfaces CDC standard&#10;            (0 until device.interfaceCount).any { i -&gt;&#10;                val intf = device.getInterface(i)&#10;                val isCdc = intf.interfaceClass == UsbConstants.USB_CLASS_CDC_DATA ||&#10;                           intf.interfaceClass == UsbConstants.USB_CLASS_COMM&#10;&#10;                Log.d(&quot;UsbCdcManager&quot;, &quot;  Interface $i: class=${intf.interfaceClass}, subclass=${intf.interfaceSubclass}, protocol=${intf.interfaceProtocol}&quot;)&#10;&#10;                if (isCdc) {&#10;                    Log.d(&quot;UsbCdcManager&quot;, &quot;  ✅ Interface CDC trouvée!&quot;)&#10;                }&#10;&#10;                isCdc&#10;            }&#10;        }&#10;&#10;        // Si aucun périphérique CDC standard trouvé, chercher des dispositifs vendor-specific&#10;        if (cdcDevice == null) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Aucun périphérique CDC standard trouvé, recherche vendor-specific...&quot;)&#10;&#10;            cdcDevice = devices.find { device -&gt;&#10;                // Recherche d'interfaces vendor-specific (class 255) qui pourraient être des CDC&#10;                (0 until device.interfaceCount).any { i -&gt;&#10;                    val intf = device.getInterface(i)&#10;                    val isVendorSpecific = intf.interfaceClass == 255 // Vendor specific&#10;&#10;                    if (isVendorSpecific) {&#10;                        Log.d(&quot;UsbCdcManager&quot;, &quot;  Trouvé interface vendor-specific: ${device.deviceName}&quot;)&#10;&#10;                        // Vérifier s'il y a des endpoints BULK IN/OUT (caractéristique des CDC)&#10;                        val hasBulkEndpoints = (0 until intf.endpointCount).any { j -&gt;&#10;                            val ep = intf.getEndpoint(j)&#10;                            ep.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                        }&#10;&#10;                        if (hasBulkEndpoints) {&#10;                            Log.d(&quot;UsbCdcManager&quot;, &quot;  ✅ Interface vendor-specific avec endpoints BULK!&quot;)&#10;                        }&#10;&#10;                        hasBulkEndpoints&#10;                    } else {&#10;                        false&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Si toujours rien, prendre le premier périphérique avec des endpoints BULK&#10;        if (cdcDevice == null &amp;&amp; devices.isNotEmpty()) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Recherche de tout périphérique avec endpoints BULK...&quot;)&#10;&#10;            cdcDevice = devices.find { device -&gt;&#10;                (0 until device.interfaceCount).any { i -&gt;&#10;                    val intf = device.getInterface(i)&#10;                    (0 until intf.endpointCount).any { j -&gt;&#10;                        val ep = intf.getEndpoint(j)&#10;                        ep.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (cdcDevice != null) {&#10;                Log.d(&quot;UsbCdcManager&quot;, &quot;✅ Périphérique avec endpoints BULK trouvé: ${cdcDevice.deviceName}&quot;)&#10;            }&#10;        }&#10;&#10;        return cdcDevice&#10;    }&#10;&#10;    private fun findCdcInterface(device: UsbDevice): android.hardware.usb.UsbInterface? {&#10;        Log.d(&quot;UsbCdcManager&quot;, &quot;=== RECHERCHE INTERFACE CDC ===&quot;)&#10;&#10;        // D'abord, chercher une interface CDC standard&#10;        var cdcInterface = (0 until device.interfaceCount).map { device.getInterface(it) }.find { intf -&gt;&#10;            val isCdcStandard = intf.interfaceClass == UsbConstants.USB_CLASS_CDC_DATA ||&#10;                               (intf.interfaceClass == UsbConstants.USB_CLASS_COMM &amp;&amp; intf.interfaceSubclass == 2)&#10;&#10;            if (isCdcStandard) {&#10;                Log.d(&quot;UsbCdcManager&quot;, &quot;✅ Interface CDC standard trouvée: class=${intf.interfaceClass}&quot;)&#10;            }&#10;&#10;            isCdcStandard&#10;        }&#10;&#10;        // Si pas trouvé, chercher une interface vendor-specific avec endpoints BULK&#10;        if (cdcInterface == null) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Recherche interface vendor-specific avec endpoints BULK...&quot;)&#10;&#10;            cdcInterface = (0 until device.interfaceCount).map { device.getInterface(it) }.find { intf -&gt;&#10;                val hasBulkEndpoints = (0 until intf.endpointCount).any { i -&gt;&#10;                    val ep = intf.getEndpoint(i)&#10;                    ep.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                }&#10;&#10;                if (hasBulkEndpoints) {&#10;                    Log.d(&quot;UsbCdcManager&quot;, &quot;✅ Interface avec endpoints BULK trouvée: class=${intf.interfaceClass}&quot;)&#10;                }&#10;&#10;                hasBulkEndpoints&#10;            }&#10;        }&#10;&#10;        // Si toujours pas trouvé, prendre la première interface&#10;        if (cdcInterface == null &amp;&amp; device.interfaceCount &gt; 0) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Utilisation de la première interface disponible...&quot;)&#10;            cdcInterface = device.getInterface(0)&#10;        }&#10;&#10;        return cdcInterface&#10;    }&#10;&#10;    fun listConnectedDevices(): List&lt;UsbDevice&gt; {&#10;        return usbManager.deviceList.values.toList()&#10;    }&#10;&#10;    /**&#10;     * Envoie un ByteArray via USB CDC&#10;     * Similaire à sendString() mais pour des données binaires&#10;     */&#10;    suspend fun sendBytes(data: ByteArray): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                addLog(&quot;=== DÉBUT ENVOI USB (ByteArray) ===&quot;)&#10;                addLog(&quot;Tentative d'envoi de ${data.size} octets&quot;)&#10;                addLog(&quot;Données (hex): ${data.take(16).joinToString(&quot; &quot;) { &quot;0x%02x&quot;.format(it) }}${if (data.size &gt; 16) &quot;...&quot; else &quot;&quot;}&quot;)&#10;&#10;                // Lister tous les périphériques connectés&#10;                val allDevices = usbManager.deviceList&#10;                addLog(&quot;Nombre de périphériques USB détectés: ${allDevices.size}&quot;)&#10;&#10;                val device = findCdcDevice()&#10;                if (device == null) {&#10;                    addLog(&quot;❌ Aucun périphérique CDC trouvé&quot;)&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Périphérique CDC trouvé: ${device.deviceName}&quot;)&#10;&#10;                if (!usbManager.hasPermission(device)) {&#10;                    addLog(&quot;⚠️ Permission requise pour le périphérique&quot;)&#10;                    val hasPermission = requestPermission(device)&#10;                    if (!hasPermission) {&#10;                        addLog(&quot;❌ Permission refusée par l'utilisateur&quot;)&#10;                        return@withContext false&#10;                    }&#10;                    addLog(&quot;✅ Permission accordée&quot;)&#10;                } else {&#10;                    addLog(&quot;✅ Permission déjà accordée&quot;)&#10;                }&#10;&#10;                val connection = usbManager.openDevice(device)&#10;                if (connection == null) {&#10;                    addLog(&quot;❌ Impossible d'ouvrir le périphérique&quot;)&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Connexion au périphérique établie&quot;)&#10;&#10;                val cdcInterface = findCdcInterface(device)&#10;                if (cdcInterface == null) {&#10;                    addLog(&quot;❌ Interface CDC non trouvée&quot;)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Interface CDC trouvée: class=${cdcInterface.interfaceClass}&quot;)&#10;&#10;                val claimResult = connection.claimInterface(cdcInterface, true)&#10;                if (!claimResult) {&#10;                    addLog(&quot;❌ Impossible de revendiquer l'interface&quot;)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Interface revendiquée avec succès&quot;)&#10;&#10;                // Recherche du endpoint de sortie&#10;                var outEndpoint = (0 until cdcInterface.endpointCount).map {&#10;                    cdcInterface.getEndpoint(it)&#10;                }.find {&#10;                    it.direction == UsbConstants.USB_DIR_OUT &amp;&amp;&#10;                    it.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                }&#10;&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;Recherche endpoint INTERRUPT OUT...&quot;)&#10;                    outEndpoint = (0 until cdcInterface.endpointCount).map {&#10;                        cdcInterface.getEndpoint(it)&#10;                    }.find {&#10;                        it.direction == UsbConstants.USB_DIR_OUT &amp;&amp;&#10;                        it.type == UsbConstants.USB_ENDPOINT_XFER_INT&#10;                    }&#10;                }&#10;&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;❌ Aucun endpoint de sortie trouvé&quot;)&#10;                    connection.releaseInterface(cdcInterface)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                val endpointType = when(outEndpoint.type) {&#10;                    UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;                addLog(&quot;✅ Endpoint de sortie trouvé: $endpointType&quot;)&#10;&#10;                addLog(&quot;Envoi de ${data.size} bytes...&quot;)&#10;&#10;                val result = if (outEndpoint.type == UsbConstants.USB_ENDPOINT_XFER_BULK) {&#10;                    connection.bulkTransfer(outEndpoint, data, data.size, 5000)&#10;                } else {&#10;                    connection.bulkTransfer(outEndpoint, data, data.size, 5000)&#10;                }&#10;&#10;                val success = result &gt;= 0&#10;                if (success) {&#10;                    addLog(&quot;✅ Données envoyées avec succès: $result bytes&quot;)&#10;                } else {&#10;                    addLog(&quot;❌ Erreur lors de l'envoi: code=$result&quot;)&#10;                }&#10;&#10;                connection.releaseInterface(cdcInterface)&#10;                connection.close()&#10;                addLog(&quot;=== FIN ENVOI USB (ByteArray) ===&quot;)&#10;                return@withContext success&#10;            } catch (e: Exception) {&#10;                addLog(&quot;❌ Exception lors de l'envoi USB: ${e.message}&quot;)&#10;                return@withContext false&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.apptest2.usb&#10;&#10;import android.app.PendingIntent&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.hardware.usb.UsbConstants&#10;import android.hardware.usb.UsbDevice&#10;import android.hardware.usb.UsbManager&#10;import android.util.Log&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;&#10;class UsbCdcManager(private val context: Context) {&#10;&#10;    private val usbManager by lazy { context.getSystemService(Context.USB_SERVICE) as UsbManager }&#10;    private val ACTION_USB_PERMISSION = &quot;com.example.apptest2.USB_PERMISSION&quot;&#10;&#10;    // Nouveau : Stockage des logs pour affichage dans l'UI&#10;    private val _logMessages = mutableListOf&lt;String&gt;()&#10;    val logMessages: List&lt;String&gt; get() = _logMessages.toList()&#10;&#10;    private fun addLog(message: String) {&#10;        val timestamp = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, java.util.Locale.getDefault()).format(java.util.Date())&#10;        val logEntry = &quot;[$timestamp] $message&quot;&#10;        _logMessages.add(logEntry)&#10;        Log.d(&quot;UsbCdcManager&quot;, message)&#10;&#10;        // Garder seulement les 50 derniers logs&#10;        if (_logMessages.size &gt; 50) {&#10;            _logMessages.removeAt(0)&#10;        }&#10;    }&#10;&#10;    fun clearLogs() {&#10;        _logMessages.clear()&#10;    }&#10;&#10;    suspend fun sendString(string: String): Boolean {&#10;        return sendData(string.toByteArray(), &quot;String: $string&quot;)&#10;    }&#10;&#10;    /**&#10;     * Envoie un ByteArray via USB CDC&#10;     * Utilise la même logique que sendString()&#10;     */&#10;    suspend fun sendBytes(data: ByteArray): Boolean {&#10;        val preview = data.take(16).joinToString(&quot; &quot;) { &quot;0x%02x&quot;.format(it) }&#10;        val description = &quot;ByteArray (${data.size} octets): $preview${if (data.size &gt; 16) &quot;...&quot; else &quot;&quot;}&quot;&#10;        return sendData(data, description)&#10;    }&#10;&#10;    /**&#10;     * Méthode privée partagée pour l'envoi de données via USB CDC&#10;     */&#10;    private suspend fun sendData(data: ByteArray, description: String): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                addLog(&quot;=== DÉBUT ENVOI USB ===&quot;)&#10;                addLog(&quot;Tentative d'envoi: $description&quot;)&#10;&#10;                // Lister tous les périphériques connectés&#10;                val allDevices = usbManager.deviceList&#10;                addLog(&quot;Nombre de périphériques USB détectés: ${allDevices.size}&quot;)&#10;&#10;                allDevices.values.forEachIndexed { index, device -&gt;&#10;                    addLog(&quot;Périphérique $index:&quot;)&#10;                    addLog(&quot;  - Nom: ${device.deviceName}&quot;)&#10;                    addLog(&quot;  - Vendor ID: 0x${device.vendorId.toString(16)}&quot;)&#10;                    addLog(&quot;  - Product ID: 0x${device.productId.toString(16)}&quot;)&#10;                    addLog(&quot;  - Nombre d'interfaces: ${device.interfaceCount}&quot;)&#10;                    addLog(&quot;  - Permission accordée: ${usbManager.hasPermission(device)}&quot;)&#10;&#10;                    // Lister toutes les interfaces&#10;                    for (i in 0 until device.interfaceCount) {&#10;                        val intf = device.getInterface(i)&#10;                        addLog(&quot;    Interface $i: class=${intf.interfaceClass}, subclass=${intf.interfaceSubclass}, protocol=${intf.interfaceProtocol}&quot;)&#10;                    }&#10;                }&#10;&#10;                val device = findCdcDevice()&#10;                if (device == null) {&#10;                    addLog(&quot;❌ Aucun périphérique CDC trouvé&quot;)&#10;                    addLog(&quot;Recherchez un périphérique avec interface class 2 (COMM) ou 10 (CDC_DATA)&quot;)&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Périphérique CDC trouvé: ${device.deviceName}&quot;)&#10;&#10;                if (!usbManager.hasPermission(device)) {&#10;                    addLog(&quot;⚠️ Permission requise pour le périphérique&quot;)&#10;                    val hasPermission = requestPermission(device)&#10;                    if (!hasPermission) {&#10;                        addLog(&quot;❌ Permission refusée par l'utilisateur&quot;)&#10;                        return@withContext false&#10;                    }&#10;                    addLog(&quot;✅ Permission accordée&quot;)&#10;                } else {&#10;                    addLog(&quot;✅ Permission déjà accordée&quot;)&#10;                }&#10;&#10;                val connection = usbManager.openDevice(device)&#10;                if (connection == null) {&#10;                    addLog(&quot;❌ Impossible d'ouvrir le périphérique&quot;)&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Connexion au périphérique établie&quot;)&#10;&#10;                // Recherche de l'interface CDC correcte&#10;                val cdcInterface = findCdcInterface(device)&#10;                if (cdcInterface == null) {&#10;                    addLog(&quot;❌ Interface CDC non trouvée&quot;)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Interface CDC trouvée: class=${cdcInterface.interfaceClass}&quot;)&#10;&#10;                val claimResult = connection.claimInterface(cdcInterface, true)&#10;                if (!claimResult) {&#10;                    addLog(&quot;❌ Impossible de revendiquer l'interface&quot;)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                addLog(&quot;✅ Interface revendiquée avec succès&quot;)&#10;&#10;                // Analyse détaillée uniquement pour les strings (pour éviter trop de logs)&#10;                if (description.startsWith(&quot;String:&quot;)) {&#10;                    addLog(&quot;=== ANALYSE DÉTAILLÉE DU PÉRIPHÉRIQUE ===&quot;)&#10;                    addLog(&quot;Vendor ID: 0x${device.vendorId.toString(16).uppercase()}&quot;)&#10;                    addLog(&quot;Product ID: 0x${device.productId.toString(16).uppercase()}&quot;)&#10;                    addLog(&quot;Device Class: ${device.deviceClass}&quot;)&#10;                    addLog(&quot;Device Subclass: ${device.deviceSubclass}&quot;)&#10;                    addLog(&quot;Device Protocol: ${device.deviceProtocol}&quot;)&#10;                    addLog(&quot;Nombre total d'interfaces: ${device.interfaceCount}&quot;)&#10;&#10;                    // Analyser TOUTES les interfaces et endpoints&#10;                    for (i in 0 until device.interfaceCount) {&#10;                        val intf = device.getInterface(i)&#10;                        addLog(&quot;Interface $i:&quot;)&#10;                        addLog(&quot;  Class: ${intf.interfaceClass} (${getUsbClassDescription(intf.interfaceClass)})&quot;)&#10;                        addLog(&quot;  Subclass: ${intf.interfaceSubclass}&quot;)&#10;                        addLog(&quot;  Protocol: ${intf.interfaceProtocol}&quot;)&#10;                        addLog(&quot;  Endpoints: ${intf.endpointCount}&quot;)&#10;&#10;                        for (j in 0 until intf.endpointCount) {&#10;                            val ep = intf.getEndpoint(j)&#10;                            val direction = if (ep.direction == UsbConstants.USB_DIR_OUT) &quot;OUT&quot; else &quot;IN&quot;&#10;                            val type = when (ep.type) {&#10;                                UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                                UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                                UsbConstants.USB_ENDPOINT_XFER_CONTROL -&gt; &quot;CONTROL&quot;&#10;                                UsbConstants.USB_ENDPOINT_XFER_ISOC -&gt; &quot;ISOCHRONOUS&quot;&#10;                                else -&gt; &quot;UNKNOWN(${ep.type})&quot;&#10;                            }&#10;                            addLog(&quot;    Endpoint $j: $direction $type (addr=0x${ep.address.toString(16)}, maxPacket=${ep.maxPacketSize})&quot;)&#10;                        }&#10;                    }&#10;                    addLog(&quot;=== FIN ANALYSE ===&quot;)&#10;                }&#10;&#10;                // Recherche du endpoint de sortie - Version améliorée&#10;                addLog(&quot;Recherche endpoint de sortie...&quot;)&#10;&#10;                // D'abord chercher un endpoint BULK OUT (standard CDC)&#10;                var outEndpoint = (0 until cdcInterface.endpointCount).map {&#10;                    cdcInterface.getEndpoint(it)&#10;                }.find {&#10;                    it.direction == UsbConstants.USB_DIR_OUT &amp;&amp;&#10;                    it.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                }&#10;&#10;                // Si pas trouvé, chercher un endpoint INTERRUPT OUT&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;Pas d'endpoint BULK OUT, recherche INTERRUPT OUT...&quot;)&#10;                    outEndpoint = (0 until cdcInterface.endpointCount).map {&#10;                        cdcInterface.getEndpoint(it)&#10;                    }.find {&#10;                        it.direction == UsbConstants.USB_DIR_OUT &amp;&amp;&#10;                        it.type == UsbConstants.USB_ENDPOINT_XFER_INT&#10;                    }&#10;                }&#10;&#10;                // Si toujours pas trouvé, chercher dans toutes les interfaces&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;Recherche endpoint de sortie dans toutes les interfaces...&quot;)&#10;                    for (i in 0 until device.interfaceCount) {&#10;                        val intf = device.getInterface(i)&#10;                        for (j in 0 until intf.endpointCount) {&#10;                            val ep = intf.getEndpoint(j)&#10;                            if (ep.direction == UsbConstants.USB_DIR_OUT) {&#10;                                addLog(&quot;Trouvé endpoint OUT dans interface $i: type=${when(ep.type) {&#10;                                    UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                                    UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                                    UsbConstants.USB_ENDPOINT_XFER_CONTROL -&gt; &quot;CONTROL&quot;&#10;                                    UsbConstants.USB_ENDPOINT_XFER_ISOC -&gt; &quot;ISOCHRONOUS&quot;&#10;                                    else -&gt; &quot;UNKNOWN&quot;&#10;                                }}&quot;)&#10;&#10;                                // Si c'est une interface différente, on doit la revendiquer&#10;                                if (i != cdcInterface.id) {&#10;                                    addLog(&quot;Changement vers interface $i...&quot;)&#10;                                    connection.releaseInterface(cdcInterface)&#10;                                    val newInterface = device.getInterface(i)&#10;                                    val claimResult2 = connection.claimInterface(newInterface, true)&#10;                                    if (!claimResult2) {&#10;                                        addLog(&quot;❌ Impossible de revendiquer l'interface $i&quot;)&#10;                                        continue&#10;                                    }&#10;                                    addLog(&quot;✅ Interface $i revendiquée&quot;)&#10;                                }&#10;                                outEndpoint = ep&#10;                                break&#10;                            }&#10;                        }&#10;                        if (outEndpoint != null) break&#10;                    }&#10;                }&#10;&#10;                if (outEndpoint == null) {&#10;                    addLog(&quot;❌ Aucun endpoint de sortie trouvé&quot;)&#10;                    connection.releaseInterface(cdcInterface)&#10;                    connection.close()&#10;                    return@withContext false&#10;                }&#10;&#10;                val endpointType = when(outEndpoint.type) {&#10;                    UsbConstants.USB_ENDPOINT_XFER_BULK -&gt; &quot;BULK&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_INT -&gt; &quot;INTERRUPT&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_CONTROL -&gt; &quot;CONTROL&quot;&#10;                    UsbConstants.USB_ENDPOINT_XFER_ISOC -&gt; &quot;ISOCHRONOUS&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;                addLog(&quot;✅ Endpoint de sortie trouvé: $endpointType, address=0x${outEndpoint.address.toString(16)}&quot;)&#10;&#10;                addLog(&quot;Envoi de ${data.size} bytes: ${data.joinToString(&quot; &quot;) { &quot;0x%02x&quot;.format(it) }}&quot;)&#10;&#10;                // Utiliser la méthode appropriée selon le type d'endpoint&#10;                val result = if (outEndpoint.type == UsbConstants.USB_ENDPOINT_XFER_BULK) {&#10;                    connection.bulkTransfer(outEndpoint, data, data.size, 5000)&#10;                } else {&#10;                    // Pour les endpoints INTERRUPT, utiliser controlTransfer ou bulkTransfer selon le périphérique&#10;                    addLog(&quot;Utilisation d'INTERRUPT endpoint...&quot;)&#10;                    connection.bulkTransfer(outEndpoint, data, data.size, 5000)&#10;                }&#10;&#10;                val success = result &gt;= 0&#10;                if (success) {&#10;                    addLog(&quot;✅ Données envoyées avec succès: $result bytes&quot;)&#10;                } else {&#10;                    addLog(&quot;❌ Erreur lors de l'envoi: code=$result&quot;)&#10;                    when (result) {&#10;                        -1 -&gt; addLog(&quot;Erreur générale ou timeout&quot;)&#10;                        -2 -&gt; addLog(&quot;Erreur de type ou paramètre invalide&quot;)&#10;                        else -&gt; addLog(&quot;Code d'erreur inconnu: $result&quot;)&#10;                    }&#10;                }&#10;&#10;                connection.releaseInterface(cdcInterface)&#10;                connection.close()&#10;                addLog(&quot;=== FIN ENVOI USB ===&quot;)&#10;                return@withContext success&#10;            } catch (e: Exception) {&#10;                addLog(&quot;❌ Exception lors de l'envoi USB: ${e.message}&quot;)&#10;                return@withContext false&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun requestPermission(device: UsbDevice): Boolean = suspendCancellableCoroutine { continuation -&gt;&#10;        val permissionIntent = PendingIntent.getBroadcast(&#10;            context, 0, Intent(ACTION_USB_PERMISSION),&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val usbReceiver = object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context, intent: Intent) {&#10;                context.unregisterReceiver(this)&#10;                if (ACTION_USB_PERMISSION == intent.action) {&#10;                    val granted = intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)&#10;                    continuation.resume(granted)&#10;                }&#10;            }&#10;        }&#10;&#10;        context.registerReceiver(&#10;            usbReceiver,&#10;            IntentFilter(ACTION_USB_PERMISSION),&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) {&#10;                Context.RECEIVER_NOT_EXPORTED&#10;            } else {&#10;                0&#10;            }&#10;        )&#10;        usbManager.requestPermission(device, permissionIntent)&#10;&#10;        continuation.invokeOnCancellation {&#10;            try {&#10;                context.unregisterReceiver(usbReceiver)&#10;            } catch (_: Exception) {&#10;                // Receiver already unregistered&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun findCdcDevice(): UsbDevice? {&#10;        val devices = usbManager.deviceList.values&#10;        Log.d(&quot;UsbCdcManager&quot;, &quot;=== RECHERCHE PÉRIPHÉRIQUE CDC ===&quot;)&#10;&#10;        // D'abord, essayer de trouver un vrai périphérique CDC&#10;        var cdcDevice = devices.find { device -&gt;&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Vérification périphérique: ${device.deviceName}&quot;)&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;  Vendor ID: 0x${device.vendorId.toString(16)}&quot;)&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;  Product ID: 0x${device.productId.toString(16)}&quot;)&#10;&#10;            // Recherche d'interfaces CDC standard&#10;            (0 until device.interfaceCount).any { i -&gt;&#10;                val intf = device.getInterface(i)&#10;                val isCdc = intf.interfaceClass == UsbConstants.USB_CLASS_CDC_DATA ||&#10;                           intf.interfaceClass == UsbConstants.USB_CLASS_COMM&#10;&#10;                Log.d(&quot;UsbCdcManager&quot;, &quot;  Interface $i: class=${intf.interfaceClass}, subclass=${intf.interfaceSubclass}, protocol=${intf.interfaceProtocol}&quot;)&#10;&#10;                if (isCdc) {&#10;                    Log.d(&quot;UsbCdcManager&quot;, &quot;  ✅ Interface CDC trouvée!&quot;)&#10;                }&#10;&#10;                isCdc&#10;            }&#10;        }&#10;&#10;        // Si aucun périphérique CDC standard trouvé, chercher des dispositifs vendor-specific&#10;        if (cdcDevice == null) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Aucun périphérique CDC standard trouvé, recherche vendor-specific...&quot;)&#10;&#10;            cdcDevice = devices.find { device -&gt;&#10;                // Recherche d'interfaces vendor-specific (class 255) qui pourraient être des CDC&#10;                (0 until device.interfaceCount).any { i -&gt;&#10;                    val intf = device.getInterface(i)&#10;                    val isVendorSpecific = intf.interfaceClass == 255 // Vendor specific&#10;&#10;                    if (isVendorSpecific) {&#10;                        Log.d(&quot;UsbCdcManager&quot;, &quot;  Trouvé interface vendor-specific: ${device.deviceName}&quot;)&#10;&#10;                        // Vérifier s'il y a des endpoints BULK IN/OUT (caractéristique des CDC)&#10;                        val hasBulkEndpoints = (0 until intf.endpointCount).any { j -&gt;&#10;                            val ep = intf.getEndpoint(j)&#10;                            ep.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                        }&#10;&#10;                        if (hasBulkEndpoints) {&#10;                            Log.d(&quot;UsbCdcManager&quot;, &quot;  ✅ Interface vendor-specific avec endpoints BULK!&quot;)&#10;                        }&#10;&#10;                        hasBulkEndpoints&#10;                    } else {&#10;                        false&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Si toujours rien, prendre le premier périphérique avec des endpoints BULK&#10;        if (cdcDevice == null &amp;&amp; devices.isNotEmpty()) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Recherche de tout périphérique avec endpoints BULK...&quot;)&#10;&#10;            cdcDevice = devices.find { device -&gt;&#10;                (0 until device.interfaceCount).any { i -&gt;&#10;                    val intf = device.getInterface(i)&#10;                    (0 until intf.endpointCount).any { j -&gt;&#10;                        val ep = intf.getEndpoint(j)&#10;                        ep.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (cdcDevice != null) {&#10;                Log.d(&quot;UsbCdcManager&quot;, &quot;✅ Périphérique avec endpoints BULK trouvé: ${cdcDevice.deviceName}&quot;)&#10;            }&#10;        }&#10;&#10;        return cdcDevice&#10;    }&#10;&#10;    private fun findCdcInterface(device: UsbDevice): android.hardware.usb.UsbInterface? {&#10;        Log.d(&quot;UsbCdcManager&quot;, &quot;=== RECHERCHE INTERFACE CDC ===&quot;)&#10;&#10;        // D'abord, chercher une interface CDC standard&#10;        var cdcInterface = (0 until device.interfaceCount).map { device.getInterface(it) }.find { intf -&gt;&#10;            val isCdcStandard = intf.interfaceClass == UsbConstants.USB_CLASS_CDC_DATA ||&#10;                               (intf.interfaceClass == UsbConstants.USB_CLASS_COMM &amp;&amp; intf.interfaceSubclass == 2)&#10;&#10;            if (isCdcStandard) {&#10;                Log.d(&quot;UsbCdcManager&quot;, &quot;✅ Interface CDC standard trouvée: class=${intf.interfaceClass}&quot;)&#10;            }&#10;&#10;            isCdcStandard&#10;        }&#10;&#10;        // Si pas trouvé, chercher une interface vendor-specific avec endpoints BULK&#10;        if (cdcInterface == null) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Recherche interface vendor-specific avec endpoints BULK...&quot;)&#10;&#10;            cdcInterface = (0 until device.interfaceCount).map { device.getInterface(it) }.find { intf -&gt;&#10;                val hasBulkEndpoints = (0 until intf.endpointCount).any { i -&gt;&#10;                    val ep = intf.getEndpoint(i)&#10;                    ep.type == UsbConstants.USB_ENDPOINT_XFER_BULK&#10;                }&#10;&#10;                if (hasBulkEndpoints) {&#10;                    Log.d(&quot;UsbCdcManager&quot;, &quot;✅ Interface avec endpoints BULK trouvée: class=${intf.interfaceClass}&quot;)&#10;                }&#10;&#10;                hasBulkEndpoints&#10;            }&#10;        }&#10;&#10;        // Si toujours pas trouvé, prendre la première interface&#10;        if (cdcInterface == null &amp;&amp; device.interfaceCount &gt; 0) {&#10;            Log.d(&quot;UsbCdcManager&quot;, &quot;Utilisation de la première interface disponible...&quot;)&#10;            cdcInterface = device.getInterface(0)&#10;        }&#10;&#10;        return cdcInterface&#10;    }&#10;&#10;    fun listConnectedDevices(): List&lt;UsbDevice&gt; {&#10;        return usbManager.deviceList.values.toList()&#10;    }&#10;&#10;    private fun getUsbClassDescription(usbClass: Int): String {&#10;        return when (usbClass) {&#10;            UsbConstants.USB_CLASS_APP_SPEC -&gt; &quot;APPLICATION_SPECIFIC&quot;&#10;            UsbConstants.USB_CLASS_AUDIO -&gt; &quot;AUDIO&quot;&#10;            UsbConstants.USB_CLASS_CDC_DATA -&gt; &quot;CDC_DATA&quot;&#10;            UsbConstants.USB_CLASS_COMM -&gt; &quot;COMMUNICATION&quot;&#10;            UsbConstants.USB_CLASS_CONTENT_SEC -&gt; &quot;CONTENT_SECURITY&quot;&#10;            UsbConstants.USB_CLASS_CSCID -&gt; &quot;SMART_CARD&quot;&#10;            UsbConstants.USB_CLASS_HID -&gt; &quot;HID&quot;&#10;            UsbConstants.USB_CLASS_HUB -&gt; &quot;HUB&quot;&#10;            UsbConstants.USB_CLASS_MASS_STORAGE -&gt; &quot;MASS_STORAGE&quot;&#10;            UsbConstants.USB_CLASS_MISC -&gt; &quot;MISCELLANEOUS&quot;&#10;            UsbConstants.USB_CLASS_PER_INTERFACE -&gt; &quot;PER_INTERFACE&quot;&#10;            UsbConstants.USB_CLASS_PRINTER -&gt; &quot;PRINTER&quot;&#10;            UsbConstants.USB_CLASS_STILL_IMAGE -&gt; &quot;STILL_IMAGE&quot;&#10;            UsbConstants.USB_CLASS_VIDEO -&gt; &quot;VIDEO&quot;&#10;            UsbConstants.USB_CLASS_WIRELESS_CONTROLLER -&gt; &quot;WIRELESS_CONTROLLER&quot;&#10;            5 -&gt; &quot;PHYSICAL&quot; // Fallback pour USB_CLASS_PHYSICAL si non disponible&#10;            255 -&gt; &quot;VENDOR_SPECIFIC&quot;&#10;            else -&gt; &quot;UNKNOWN($usbClass)&quot;&#10;        }&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/wristband/WristbandNative.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/apptest2/wristband/WristbandNative.kt" />
              <option name="originalContent" value="package com.example.apptest2.wristband&#10;&#10;/**&#10; * Interface native pour la librairie wristband_objects&#10; * Cette classe permet de générer et manipuler les trames du protocole wristband&#10; */&#10;class WristbandNative {&#10;&#10;    companion object {&#10;        // Charger la librairie native au démarrage&#10;        init {&#10;            System.loadLibrary(&quot;wristband_native&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Initialise la librairie wristband_objects&#10;     * @return true si l'initialisation s'est bien passée&#10;     */&#10;    external fun initialize(): Boolean&#10;&#10;    /**&#10;     * Génère une trame Event complète avec tous les paramètres&#10;     * @param eventId ID de l'event (0-255)&#10;     * @param mask Masque de destination&#10;     * @param targetUid UID cible&#10;     * @param startTimeMs Temps de début en ms (relatif)&#10;     * @param stopTimeMs Temps de fin en ms (relatif)&#10;     * @param styleValue Style de l'effet (voir enum Style)&#10;     * @param frequency Fréquence de l'effet (1-20 Hz)&#10;     * @param duration Durée de l'effet en ms&#10;     * @param intensity Intensité (0-255)&#10;     * @param colorArray Tableau de 5 couleurs [R, G, B, W, Vibration]&#10;     * @return ByteArray contenant la trame encodée prête à envoyer&#10;     */&#10;    external fun generateEventFrame(&#10;        eventId: Int,&#10;        mask: Int,&#10;        targetUid: Long,&#10;        startTimeMs: Int,&#10;        stopTimeMs: Int,&#10;        styleValue: Int,&#10;        frequency: Int,&#10;        duration: Int,&#10;        intensity: Int,&#10;        colorArray: IntArray&#10;    ): ByteArray&#10;&#10;    /**&#10;     * Génère une trame Event simple avec paramètres par défaut&#10;     * @param eventId ID de l'event (0-255)&#10;     * @param styleValue Style de l'effet (voir enum Style)&#10;     * @param red Composante rouge (0-255)&#10;     * @param green Composante verte (0-255)&#10;     * @param blue Composante bleue (0-255)&#10;     * @param white Composante blanche (0-255)&#10;     * @param vibration Intensité de vibration (0-255)&#10;     * @return ByteArray contenant la trame encodée prête à envoyer&#10;     */&#10;    external fun generateSimpleEventFrame(&#10;        eventId: Int,&#10;        styleValue: Int,&#10;        red: Int,&#10;        green: Int,&#10;        blue: Int,&#10;        white: Int,&#10;        vibration: Int&#10;    ): ByteArray&#10;&#10;    /**&#10;     * Valide une trame selon le protocole wristband&#10;     * @param frame Trame à valider&#10;     * @return true si la trame est valide&#10;     */&#10;    external fun validateFrame(frame: ByteArray): Boolean&#10;&#10;    /**&#10;     * Parse une trame reçue selon le protocole wristband&#10;     * @param frame Trame à parser&#10;     * @return Les données parsées ou une chaîne vide en cas d'erreur&#10;     */&#10;    external fun parseFrame(frame: ByteArray): String&#10;}&#10;&#10;/**&#10; * Énumération des styles disponibles (correspond à l'enum C++)&#10; */&#10;enum class WristbandStyle(val value: Int) {&#10;    ON(0),&#10;    OFF(1),&#10;    STROBE(2),&#10;    WAVE(3),&#10;    PW(4),&#10;    HEARTBEAT(5),&#10;    SPARKLE(6),&#10;    PULSE(7),&#10;    RANDOM(8),&#10;    ACC_ON(9),&#10;    ACC_ON_XYZ(10),&#10;    ACC_CLAP(11),&#10;    ACC_POSITION(12),&#10;    ACC_FLASH(13),&#10;    CLEAR(14),&#10;    ACC_HOLO(15),&#10;    BOOM(16)&#10;}&#10;&#10;/**&#10; * Classe de données pour une couleur wristband&#10; */&#10;data class WristbandColor(&#10;    val red: Int = 0,&#10;    val green: Int = 0,&#10;    val blue: Int = 0,&#10;    val white: Int = 0,&#10;    val vibration: Int = 0&#10;) {&#10;    fun toIntArray(): IntArray = intArrayOf(red, green, blue, white, vibration)&#10;}&#10;&#10;/**&#10; * Gestionnaire de haut niveau pour les trames wristband&#10; * Encapsule l'interface native et fournit des méthodes pratiques&#10; */&#10;class WristbandFrameManager {&#10;    private val nativeInterface = WristbandNative()&#10;    private var isInitialized = false&#10;    private var eventIdCounter = 0&#10;&#10;    /**&#10;     * Initialise le gestionnaire de trames&#10;     */&#10;    fun initialize(): Boolean {&#10;        if (!isInitialized) {&#10;            isInitialized = nativeInterface.initialize()&#10;        }&#10;        return isInitialized&#10;    }&#10;&#10;    /**&#10;     * Génère une trame Event simple avec couleur et style&#10;     * @param style Style de l'effet&#10;     * @param color Couleur de l'effet&#10;     * @return ByteArray de la trame encodée&#10;     */&#10;    fun generateSimpleEvent(&#10;        style: WristbandStyle,&#10;        color: WristbandColor&#10;    ): ByteArray {&#10;        ensureInitialized()&#10;        val eventId = getNextEventId()&#10;&#10;        return nativeInterface.generateSimpleEventFrame(&#10;            eventId,&#10;            style.value,&#10;            color.red,&#10;            color.green,&#10;            color.blue,&#10;            color.white,&#10;            color.vibration&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Génère une trame Event complète avec tous les paramètres&#10;     */&#10;    fun generateCompleteEvent(&#10;        style: WristbandStyle,&#10;        color: WristbandColor,&#10;        frequency: Int = 10,&#10;        duration: Int = 100,&#10;        intensity: Int = 255,&#10;        startTimeMs: Int = 0,&#10;        stopTimeMs: Int = 10000,&#10;        mask: Int = 0xFF,&#10;        targetUid: Long = 0&#10;    ): ByteArray {&#10;        ensureInitialized()&#10;        val eventId = getNextEventId()&#10;&#10;        return nativeInterface.generateEventFrame(&#10;            eventId,&#10;            mask,&#10;            targetUid,&#10;            startTimeMs,&#10;            stopTimeMs,&#10;            style.value,&#10;            frequency,&#10;            duration,&#10;            intensity,&#10;            color.toIntArray()&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Valide une trame reçue&#10;     */&#10;    fun validateFrame(frame: ByteArray): Boolean {&#10;        ensureInitialized()&#10;        return nativeInterface.validateFrame(frame)&#10;    }&#10;&#10;    /**&#10;     * Parse une trame reçue et retourne les données&#10;     */&#10;    fun parseFrame(frame: ByteArray): String {&#10;        ensureInitialized()&#10;        return nativeInterface.parseFrame(frame)&#10;    }&#10;&#10;    /**&#10;     * Convertit un ByteArray en String hexadécimale pour le debug&#10;     */&#10;    fun frameToHexString(frame: ByteArray): String {&#10;        return frame.joinToString(&quot; &quot;) { byte -&gt; &quot;%02X&quot;.format(byte) }&#10;    }&#10;&#10;    private fun ensureInitialized() {&#10;        if (!isInitialized) {&#10;            throw IllegalStateException(&quot;WristbandFrameManager n'est pas initialisé. Appelez initialize() d'abord.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getNextEventId(): Int {&#10;        eventIdCounter = (eventIdCounter + 1) % 256&#10;        return eventIdCounter&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.apptest2.wristband&#10;&#10;// Classes de données pour les couleurs et styles&#10;data class WristbandColor(&#10;    val red: Int,&#10;    val green: Int,&#10;    val blue: Int&#10;)&#10;&#10;enum class WristbandStyle {&#10;    ON,&#10;    STROBE,&#10;    PULSE,&#10;    HEARTBEAT&#10;}&#10;&#10;// Interface JNI pour la librairie C++ wristband_objects&#10;class WristbandNative {&#10;&#10;    companion object {&#10;        // Charger la librairie native au démarrage&#10;        init {&#10;            System.loadLibrary(&quot;wristband_native&quot;)&#10;        }&#10;    }&#10;&#10;    // Fonctions natives qui appellent la librairie C++ wristband_objects&#10;    external fun createHelloMessage(sourceVersion: String, sourceName: String, destinationMask: Int): ByteArray&#10;    external fun createEventMessage(style: Int, red: Int, green: Int, blue: Int): ByteArray&#10;    external fun createCommandMessage(command: Int, param1: Int, param2: Int): ByteArray&#10;    external fun validateFrame(frame: ByteArray): Boolean&#10;    external fun getFrameInfo(frame: ByteArray): String&#10;}&#10;&#10;// Gestionnaire des trames wristband&#10;class WristbandFrameManager {&#10;    private val wristbandNative = WristbandNative()&#10;&#10;    fun initialize(): Boolean {&#10;        return try {&#10;            // Test simple pour vérifier que la librairie native fonctionne&#10;            val testFrame = wristbandNative.createHelloMessage(&quot;1.0&quot;, &quot;Android&quot;, 0)&#10;            testFrame != null &amp;&amp; testFrame.isNotEmpty()&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;WristbandFrameManager&quot;, &quot;Erreur d'initialisation: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    fun generateSimpleEvent(style: WristbandStyle, color: WristbandColor): ByteArray {&#10;        try {&#10;            val styleInt = when (style) {&#10;                WristbandStyle.ON -&gt; 0        // Style::On = 0&#10;                WristbandStyle.STROBE -&gt; 2    // Style::Strobe = 2&#10;                WristbandStyle.PULSE -&gt; 7     // Style::Pulse = 7&#10;                WristbandStyle.HEARTBEAT -&gt; 5 // Style::Heartbeat = 5&#10;            }&#10;            &#10;            android.util.Log.d(&quot;WristbandFrameManager&quot;, &quot;Génération Event: style=$styleInt, color=(${color.red},${color.green},${color.blue})&quot;)&#10;            &#10;            val result = wristbandNative.createEventMessage(styleInt, color.red, color.green, color.blue)&#10;            &#10;            if (result == null) {&#10;                android.util.Log.e(&quot;WristbandFrameManager&quot;, &quot;createEventMessage a retourné null&quot;)&#10;                throw RuntimeException(&quot;Impossible de générer la trame Event&quot;)&#10;            }&#10;            &#10;            android.util.Log.d(&quot;WristbandFrameManager&quot;, &quot;Event généré avec succès: ${result.size} octets&quot;)&#10;            return result&#10;            &#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;WristbandFrameManager&quot;, &quot;Erreur lors de la génération Event: ${e.message}&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    fun generateHelloMessage(sourceVersion: String, sourceName: String, destinationMask: Int): ByteArray {&#10;        return wristbandNative.createHelloMessage(sourceVersion, sourceName, destinationMask)&#10;    }&#10;&#10;    fun generateCommandMessage(command: Int, param1: Int, param2: Int): ByteArray {&#10;        return wristbandNative.createCommandMessage(command, param1, param2)&#10;    }&#10;&#10;    fun validateFrame(frame: ByteArray): Boolean {&#10;        return wristbandNative.validateFrame(frame)&#10;    }&#10;&#10;    fun frameToHexString(frame: ByteArray): String {&#10;        return frame.joinToString(&quot; &quot;) { &quot;0x%02x&quot;.format(it) }&#10;    }&#10;&#10;    fun getFrameInfo(frame: ByteArray): String {&#10;        return wristbandNative.getFrameInfo(frame)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>